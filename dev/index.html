<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TrypColonies.jl</title><meta name="title" content="Home · TrypColonies.jl"/><meta property="og:title" content="Home · TrypColonies.jl"/><meta property="twitter:title" content="Home · TrypColonies.jl"/><meta name="description" content="Documentation for TrypColonies.jl."/><meta property="og:description" content="Documentation for TrypColonies.jl."/><meta property="twitter:description" content="Documentation for TrypColonies.jl."/><meta property="og:url" content="https://AndreasKuhn-ak.github.io/2026-Kuhn-et-al\n\n/"/><meta property="twitter:url" content="https://AndreasKuhn-ak.github.io/2026-Kuhn-et-al\n\n/"/><link rel="canonical" href="https://AndreasKuhn-ak.github.io/2026-Kuhn-et-al\n\n/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TrypColonies.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TrypColonies"><a class="docs-heading-anchor" href="#TrypColonies">TrypColonies</a><a id="TrypColonies-1"></a><a class="docs-heading-anchor-permalink" href="#TrypColonies" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/&quot;AndreasKuhn-ak&quot;/TrypColonies.jl">TrypColonies</a>.</p><ul><li><a href="#TrypColonies.Figure_observables"><code>TrypColonies.Figure_observables</code></a></li><li><a href="#TrypColonies.agent"><code>TrypColonies.agent</code></a></li><li><a href="#TrypColonies.parameters"><code>TrypColonies.parameters</code></a></li><li><a href="#TrypColonies.parameters_physical"><code>TrypColonies.parameters_physical</code></a></li><li><a href="#TrypColonies.plot_parameters"><code>TrypColonies.plot_parameters</code></a></li><li><a href="#TrypColonies.adsorb!"><code>TrypColonies.adsorb!</code></a></li><li><a href="#TrypColonies.ana_order_para_circle-Tuple{Any, parameters}"><code>TrypColonies.ana_order_para_circle</code></a></li><li><a href="#TrypColonies.ana_order_para_vicsek-Tuple{Any, parameters}"><code>TrypColonies.ana_order_para_vicsek</code></a></li><li><a href="#TrypColonies.angle_between_vec-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>TrypColonies.angle_between_vec</code></a></li><li><a href="#TrypColonies.angular_metric-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.angular_metric</code></a></li><li><a href="#TrypColonies.area_gain-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.area_gain</code></a></li><li><a href="#TrypColonies.calc_path"><code>TrypColonies.calc_path</code></a></li><li><a href="#TrypColonies.calc_repulsion-Tuple{Any, Any, Any}"><code>TrypColonies.calc_repulsion</code></a></li><li><a href="#TrypColonies.calculate_outgoing_vec-Tuple{TrypColonies.agent, Vector{Float64}}"><code>TrypColonies.calculate_outgoing_vec</code></a></li><li><a href="#TrypColonies.chemotactic_alignment-Tuple{Any, Any, Any, Any, Any, Any, Any, parameters}"><code>TrypColonies.chemotactic_alignment</code></a></li><li><a href="#TrypColonies.chose_interaction_radius-Tuple{parameters}"><code>TrypColonies.chose_interaction_radius</code></a></li><li><a href="#TrypColonies.create_buttons-Tuple{Makie.Figure, TrypColonies.Figure_observables, parameters, plot_parameters}"><code>TrypColonies.create_buttons</code></a></li><li><a href="#TrypColonies.create_data_path_vector-Tuple{Any}"><code>TrypColonies.create_data_path_vector</code></a></li><li><a href="#TrypColonies.create_exp_scalar_grid-Tuple{parameters}"><code>TrypColonies.create_exp_scalar_grid</code></a></li><li><a href="#TrypColonies.create_grids-Tuple{parameters}"><code>TrypColonies.create_grids</code></a></li><li><a href="#TrypColonies.create_noise_dis-Tuple{parameters}"><code>TrypColonies.create_noise_dis</code></a></li><li><a href="#TrypColonies.create_para_struct-Tuple{Dict}"><code>TrypColonies.create_para_struct</code></a></li><li><a href="#TrypColonies.create_para_struct_vec-Tuple{Any}"><code>TrypColonies.create_para_struct_vec</code></a></li><li><a href="#TrypColonies.create_sweep_para_vec-Tuple{Any}"><code>TrypColonies.create_sweep_para_vec</code></a></li><li><a href="#TrypColonies.create_veloctiy_dis-Tuple{parameters}"><code>TrypColonies.create_veloctiy_dis</code></a></li><li><a href="#TrypColonies.cross_2d-Tuple{Vector{T} where T&lt;:Real, Vector{T} where T&lt;:Real}"><code>TrypColonies.cross_2d</code></a></li><li><a href="#TrypColonies.find_data_path-Tuple{}"><code>TrypColonies.find_data_path</code></a></li><li><a href="#TrypColonies.find_free_neighbour_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><code>TrypColonies.find_free_neighbour_points</code></a></li><li><a href="#TrypColonies.find_neighbour_agents-NTuple{4, Any}"><code>TrypColonies.find_neighbour_agents</code></a></li><li><a href="#TrypColonies.find_right_tangent_points-Tuple{Vector{Vector{Int64}}}"><code>TrypColonies.find_right_tangent_points</code></a></li><li><a href="#TrypColonies.find_surounding_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><code>TrypColonies.find_surounding_points</code></a></li><li><a href="#TrypColonies.find_tangent_points-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>TrypColonies.find_tangent_points</code></a></li><li><a href="#TrypColonies.foldersize"><code>TrypColonies.foldersize</code></a></li><li><a href="#TrypColonies.get_reflected_vec-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><code>TrypColonies.get_reflected_vec</code></a></li><li><a href="#TrypColonies.initialize_system-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}"><code>TrypColonies.initialize_system</code></a></li><li><a href="#TrypColonies.length_vec-Tuple{Vector{Int64}}"><code>TrypColonies.length_vec</code></a></li><li><a href="#TrypColonies.make_para_dict_list-Tuple{Any}"><code>TrypColonies.make_para_dict_list</code></a></li><li><a href="#TrypColonies.make_sys_interactive!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, Any}"><code>TrypColonies.make_sys_interactive!</code></a></li><li><a href="#TrypColonies.moving_avg"><code>TrypColonies.moving_avg</code></a></li><li><a href="#TrypColonies.nearby_neighbours-Tuple{Any, Any, Any}"><code>TrypColonies.nearby_neighbours</code></a></li><li><a href="#TrypColonies.path_tracing-Tuple{Matrix{Int64}, TrypColonies.agent, Any, parameters}"><code>TrypColonies.path_tracing</code></a></li><li><a href="#TrypColonies.periodic_boundary_correction-Tuple{Int64, Int64, Tuple{Int64, Int64}}"><code>TrypColonies.periodic_boundary_correction</code></a></li><li><a href="#TrypColonies.radial_density_c-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.radial_density_c</code></a></li><li><a href="#TrypColonies.radial_distribution-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.radial_distribution</code></a></li><li><a href="#TrypColonies.reconstruct_grid!-Tuple{Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}, Int64, AbstractArray{Int64}}"><code>TrypColonies.reconstruct_grid!</code></a></li><li><a href="#TrypColonies.reconstruct_grid_from_scratch"><code>TrypColonies.reconstruct_grid_from_scratch</code></a></li><li><a href="#TrypColonies.remove_fields_dict!-Tuple{Any}"><code>TrypColonies.remove_fields_dict!</code></a></li><li><a href="#TrypColonies.res_scaling-Tuple{Any}"><code>TrypColonies.res_scaling</code></a></li><li><a href="#TrypColonies.save_grid_changes!-Tuple{Matrix{Int64}, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}"><code>TrypColonies.save_grid_changes!</code></a></li><li><a href="#TrypColonies.scale_color_map-Tuple{Any, Any}"><code>TrypColonies.scale_color_map</code></a></li><li><a href="#TrypColonies.scale_time_step-Tuple{Any, Any}"><code>TrypColonies.scale_time_step</code></a></li><li><a href="#TrypColonies.strenghten_boundary!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}"><code>TrypColonies.strenghten_boundary!</code></a></li><li><a href="#TrypColonies.sweep_and_save_parallel_t"><code>TrypColonies.sweep_and_save_parallel_t</code></a></li><li><a href="#TrypColonies.update_grid!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}"><code>TrypColonies.update_grid!</code></a></li><li><a href="#TrypColonies.update_position!"><code>TrypColonies.update_position!</code></a></li><li><a href="#TrypColonies.@h-Tuple{Any}"><code>TrypColonies.@h</code></a></li></ul><article><details class="docstring" open="true"><summary id="TrypColonies.Figure_observables"><a class="docstring-binding" href="#TrypColonies.Figure_observables"><code>TrypColonies.Figure_observables</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Figure_observables</code></pre><p>A structure to hold various observables for visualizing simulation data.</p><p><strong>Fields</strong></p><ul><li><code>Time::Observable{Int64}</code>: An observable for the current time step.</li><li><code>V_a::Observable{CircularBuffer{Point2f}}</code>: An observable for a circular buffer of 2D points represent a correlation function.</li><li><code>V_a_length::Observable{Int64}</code>: An observable for the length of <code>V_a</code>.</li><li><code>X::Observable{Vector{Float64}}</code>: An observable for the x-coordinates of agents.</li><li><code>Y::Observable{Vector{Float64}}</code>: An observable for the y-coordinates of agents.</li><li><code>U::Observable{Vector{Float64}}</code>: An observable for the x-components of agent velocities.</li><li><code>V::Observable{Vector{Float64}}</code>: An observable for the y-components of agent velocities.</li><li><code>N::Observable{Int64}</code>: An observable for the number of agents.</li><li><code>Grid_contour::Observable{Matrix{Int64}}</code>: An observable for the grid which the agents move on.</li><li><code>Theta::Observable{Vector{Float64}}</code>: An observable for the angles of agents.</li><li><code>Isrunning::Observable{Bool}</code>: An observable to indicate if the simulation is running.</li><li><code>Color_scaled</code>: An observable for the scaled color values to make non-dynamic or dynamic colorscaling possible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Visu.jl#L81-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.agent"><a class="docstring-binding" href="#TrypColonies.agent"><code>TrypColonies.agent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">agent</code></pre><p>A struct representing an agent in a grid. It holds the agent&#39;s current position in the grid as well as its direction of movement.</p><p><strong>Fields</strong></p><ul><li><code>x_pos::Int64</code>: The x-coordinate of the agent&#39;s position in the grid.</li><li><code>y_pos::Int64</code>: The y-coordinate of the agent&#39;s position in the grid.</li><li><code>dir_x::Float64</code>: The x-component of the agent&#39;s direction vector.</li><li><code>dir_y::Float64</code>: The y-component of the agent&#39;s direction vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L170-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.parameters"><a class="docstring-binding" href="#TrypColonies.parameters"><code>TrypColonies.parameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">parameters</code></pre><p>Defines the parameters for the simulation with default values and possible options for certain fields.</p><p><strong>Fields</strong></p><ul><li><code>pa_ph::parameters_physical</code>: A struct containing physical parameters for the simulation.</li><li><code>interaction_radius::Int64</code>: The radius within which agents interact. Default is 7.</li><li><code>boundary_conditions::String</code>: The type of boundary conditions. Default is &quot;periodic&quot;.</li><li><code>geometry::String</code>: The geometry of the simulation area. Default is &quot;circle&quot;.</li><li><code>start_config::String</code>: The initial configuration of agents. Default is &quot;random&quot;.</li><li><code>start_config_gradient::String</code>: The initial configuration of the gradient. Default is &quot;random&quot;.</li><li><code>boundary_moveable::Bool</code>: Whether the boundary is moveable. Default is true.</li><li><code>path_tracing::Bool</code>: Whether to trace the path of agents. Default is true.</li><li><code>sliding_movement::Bool</code>: Whether the boundary allows sliding. Default is false.</li><li><code>repulsion_flag::Bool</code>: Whether repulsion is enabled. Default is false.</li><li><code>repulsion_range::Int64</code>: The range of repulsion. Default is 3.</li><li><code>chemotaxis_flag::Bool</code>: Whether chemotaxis is enabled. Default is true.</li><li><code>size::Tuple{Int, Int}</code>: The dimensions of the simulation grid. Default is <code>pa_ph.N_abm</code>.</li><li><code>xc_w::LinRange{Float64, Int64}</code>: A linear range of x coordinates for the grid.</li><li><code>yc_w::LinRange{Float64, Int64}</code>: A linear range of y coordinates for the grid.</li><li><code>arrow_to_grid_fac_x::Float64</code>: The scaling factor for x coordinates from arrows to grid.</li><li><code>arrow_to_grid_fac_y::Float64</code>: The scaling factor for y coordinates from arrows to grid.</li><li><code>velocity::Float64</code>: The initial velocity of agents. Default is <code>pa_ph.walker_step_size</code>.</li><li><code>timesteps::Int64</code>: The number of timesteps the simulation runs. Default is calculated from <code>pa_ph.total_time</code> and <code>pa_ph.Δt_walker</code>.</li><li><code>velocity_variance::Float64</code>: The variance in agent velocities. Default is <code>pa_ph.walker_step_size * pa_ph.velo_var_relative</code>.</li><li><code>growth_rate::Float64</code>: The growth rate. Default is <code>pa_ph.growth_rate</code>.</li></ul><p><strong>Usage Notes</strong></p><ul><li>Use <code>reflective</code> boundary conditions only when agents cannot leave the grid space; otherwise, the simulation may crash silently.</li><li>The <code>geometry</code> field allows for simulating different environmental layouts, which can significantly affect agent behavior and interactions.</li><li>The <code>start_config</code> field determines the initial placement of agents, which can influence the dynamics of the simulation from the outset.</li></ul><p>This struct is used to configure and initialize the simulation environment, affecting how agents move, interact, and evolve over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L79-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.parameters_physical"><a class="docstring-binding" href="#TrypColonies.parameters_physical"><code>TrypColonies.parameters_physical</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">parameters_physical</code></pre><p>A struct representing the physical parameters for a simulation involving walkers and diffusion processes. This struct is initialized with default values and includes various fields related to the simulation&#39;s spatial and temporal properties.</p><p><strong>Fields</strong></p><ul><li><code>N::Tuple{Int, Int}</code>: The number of grid points in the x and y directions in the gradient grid. Default is <code>(1000, 1000)</code>.</li><li><code>scale_fac::UInt</code>: The scaling factor between the gradient grid where the diffusion is calculated and the one of the ABM. Default is <code>4</code>.</li><li><code>L::Tuple{Float64, Float64}</code>: The physical dimensions of the simulation domain in the x and y directions. Default is <code>(0.015, 0.015)</code>.</li><li><code>agent_number::Int64</code>: The number of agents in the simulation. Default is <code>250000</code>.</li><li><code>walker_speed_phy::Float64</code>: The physical speed of the walkers in m/s. Default is <code>5*10^-6</code>.</li><li><code>Diff_coe::Float64</code>: The diffusion coefficient in m^2/s. Default is <code>7*10^-10</code>.</li><li><code>total_time::Float64</code>: The total simulation time in s. Default is <code>200.0</code>.</li><li><code>growth_rate::Float64</code>: The growth rate in 1/s. Default is <code>1.157*10^-5</code>.</li><li><code>walker_step_size::Int</code>: The step size for the walkers on the ABM grid. Default is <code>3</code>.</li><li><code>decay_rate::Float64</code>: The decay rate in 1/s. Default is <code>0.001</code>.</li><li><code>adsorption_rate::Float64</code>: The adsorption rate/amount in 1/s . Default is <code>0.001</code>.</li><li><code>Diameter_colony::Float64</code>: The diameter of the colony in m. Default is <code>0.003</code>.</li><li><code>noise_dis::Any</code>: The distribution for noise. Default is <code>Normal</code>.</li><li><code>noise_strength::Number</code>: The stdd of the noise distribution. Default is <code>0.5</code>.</li><li><code>velocity_dis::Any</code>: The distribution for velocity. Default is <code>Normal</code>.</li><li><code>velo_var_relative::Float64</code>: The relative variance in velocity. Default is <code>1.5</code>.</li><li><code>grid_strength::Int64</code>: The strength of the grid. Default is <code>100</code>.</li><li><code>grid_recover_rate::Float64</code>: The recovery rate of the grid. Default is <code>10.0</code>.</li><li><code>radius_tanget::Int64</code>: The radius to calculate the tangent which is needed to calculate the reflection on walls. Default is <code>6</code>.</li><li><code>radius_collision::Int64</code>: The radius for collision interactions. Default is <code>5</code>.</li><li><code>N_abm::Tuple{Int, Int}</code>: The number of grid points in the ABM grid, calculated as <code>N .* scale_fac</code>.</li><li><code>dx::Float64</code>: The grid spacing in the x direction, calculated as <code>L[1]/N[1]</code>.</li><li><code>dy::Float64</code>: The grid spacing in the y direction, calculated as <code>L[2]/N[2]</code>.</li><li><code>xc::LinRange{Float64, Int64}</code>: A linear range of x coordinates from <code>0.0</code> to <code>L[1]</code> with <code>N[1]</code> points.</li><li><code>yc::LinRange{Float64, Int64}</code>: A linear range of y coordinates from <code>0.0</code> to <code>L[2]</code> with <code>N[2]</code> points.</li><li><code>Δt_diff_min::Float64</code>: The minimum time step for diffusion, calculated as <code>(minimum((L./(N)))^2*2)/(8*Diff_coe+minimum((L./(N)))^2*decay_rate)</code> (see Von Neumann stability analysis).</li><li><code>Δt_walker_min::Float64</code>: The minimum time step for walkers, calculated as <code>(minimum((L./(N_abm)))*walker_step_size)/walker_speed_phy</code>.</li><li><code>Δt_diff::Float64</code>: The time step for diffusion, calculated using <code>scale_time_step</code>.</li><li><code>Δt_walker::Float64</code>: The time step for walkers, calculated using <code>scale_time_step</code>.</li><li><code>ratio_walker_diff::Int</code>: The ratio of walker time steps to diffusion time steps, calculated using <code>scale_time_step</code>.</li><li><code>time_steps_to_compute::Int</code>: The total number of time steps to compute, calculated as <code>round(Int, total_time/Δt_diff)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L1-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.plot_parameters"><a class="docstring-binding" href="#TrypColonies.plot_parameters"><code>TrypColonies.plot_parameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">plot_parameters</code></pre><p>A structure defining parameters for plotting with default values.</p><p><strong>Fields</strong></p><ul><li><code>framerate</code>: The number of frames per second in the animation. Default is 60.</li><li><code>theme</code>: The plotting theme, using <code>Attributes</code>. Default is <code>theme_ggplot2()</code>.</li><li><code>fontsize</code>: The font size for text elements. Default is 22.</li><li><code>arrow_tip_size</code>: The size of the arrow tips. Default is 12.</li><li><code>arrow_tail_length</code>: The length of the arrow tails. Default is 5.</li><li><code>refresh_delay</code>: The delay between refreshes in seconds. Default is 0.05.</li><li><code>res</code>: The resolution of the plot as a tuple (width, height). Default is (1400, 2000).</li><li><code>Color_arrows</code>: The color scheme for arrows. Default is the full range of <code>ColorSchemes.hsv</code>.</li><li><code>Color_heatmap</code>: The color scheme for heatmaps. Default is indices 50 to 100 of <code>ColorSchemes.bone</code>.</li><li><code>timesteps_corfunc</code>: The number of timesteps for the correlation function. Default is 100.</li><li><code>cor_func</code>: The correlation function for circles. Default is <code>order_parameter_circle</code>.</li></ul><p><strong>Usage</strong></p><p>This struct is used to configure the visual aspects and functionalities of plots, including animations, color schemes, and correlation calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Visu.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.adsorb!"><a class="docstring-binding" href="#TrypColonies.adsorb!"><code>TrypColonies.adsorb!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">adsorb!(grids::Tuple{Matrix{Int64}, Matrix{Float64}}, full_agent_list, para::parameters, time_step::Int64 = 1)</code></pre><p>Updates the gradient grid based on the positions of agents and their adsorption rates.</p><p><strong>Arguments</strong></p><ul><li><code>grids::Tuple{Matrix{Int64}, Matrix{Float64}}</code>: A tuple containing two matrices.    The second matrix represents the concentration of a chemical.</li><li><code>full_agent_list</code>: A list of agents, which can be either a CircularBuffer of vectors of agents    or a vector of vectors of agents.</li><li><code>para::parameters</code>: A struct containing various parameters, including adsorption rate and    time step for the agents.</li><li><code>time_step::Int64</code>: The current time step (default is 1).</li></ul><p><strong>Description</strong></p><p>This function updates the gradient grid by increasing the concentration  at the positions of the agents.      The amount of increase is determined by the adsorption rate and the time step specified in the <code>para</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Adsorption.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.ana_order_para_circle-Tuple{Any, parameters}"><a class="docstring-binding" href="#TrypColonies.ana_order_para_circle-Tuple{Any, parameters}"><code>TrypColonies.ana_order_para_circle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ana_order_para_circle(data, para::parameters; time_steady::Float64=0.7) -&gt; Float64</code></pre><p>Calculates the average order parameter over a specified steady-state period.</p><p><strong>Arguments</strong></p><ul><li><code>data::save_model_data</code>: An tuple contain an array as first element where each array element represents data points over time.</li><li><code>para::parameters</code>: A structure containing parameters required for the <code>order_parameter_circle</code> function.</li><li><code>time_steady::Float64</code>: A fraction of the total time steps to consider as the steady-state period (default is 0.7).</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The average order parameter over the steady-state period.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">data = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
para = parameters(...)
result = ana_order_para_circle(data, para)
# result is the average order parameter over the steady-state period</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L133-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.ana_order_para_vicsek-Tuple{Any, parameters}"><a class="docstring-binding" href="#TrypColonies.ana_order_para_vicsek-Tuple{Any, parameters}"><code>TrypColonies.ana_order_para_vicsek</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ana_order_para_vicsek(data, para::parameters; time_steady=0.7) -&gt; Float64</code></pre><p>Calculates the average order parameter for the Vicsek model over the steady-state period of the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: A collection of data points, where <code>data[1]</code> contains the time series data for which the order parameter is to be calculated.</li><li><code>para::parameters</code>: A struct containing the parameters required by the <code>order_parameter</code> function.</li><li><code>time_steady::Float64=0.7</code> (optional): The fraction of the total time steps to be considered as the steady-state period. Default is 0.7.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The average order parameter over the steady-state period.</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">data = [...]  # Assume this is the data collected from the simulation
para = parameters(...)  # Assume this is the parameters struct
average_order = ana_order_para_vicsek(data, para, time_steady=0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L94-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.angle_between_vec-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}"><a class="docstring-binding" href="#TrypColonies.angle_between_vec-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>TrypColonies.angle_between_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angle_between_vec(v1::Vector{&lt;:Real}, v2::Vector{&lt;:Real}) -&gt; Real</code></pre><p>Calculates the signed angle between two 2D vectors <code>v1</code> and <code>v2</code> using the arctangent of the 2D cross product and the dot product.</p><p><strong>Arguments</strong></p><ul><li><code>v1::Vector{Real}</code>: The first 2D vector.</li><li><code>v2::Vector{Real}</code>: The second 2D vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>Real</code>: The angle between the two vectors in radians.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">v1 = [1.0, 0.0]
v2 = [0.0, 1.0]
angle = angle_between_vec(v1, v2)
# angle is π/2 (1.5707963267948966 radians)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L365-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.angular_metric-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><a class="docstring-binding" href="#TrypColonies.angular_metric-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.angular_metric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">angular_metric(agent_list::Vector{agent}, grid::AbstractArray, para::parameters; steps::Int = 360)</code></pre><p>Calculates the angular distribution of non-zero pixels in the grid relative to the center.</p><p><strong>Arguments</strong></p><ul><li><code>agent_list::Vector{agent}</code>: A vector containing the agents.</li><li><code>grid::AbstractArray</code>: The grid representing the simulation space.</li><li><code>para::parameters</code>: A struct containing various parameters, including the size of the grid.</li><li><code>steps::Int</code>: The number of angular steps to divide the circle into (default is 360).</li></ul><p><strong>Description</strong></p><p>This function calculates the angular distribution of non-zero pixels in the grid relative to the center.      It performs the following steps:</p><ol><li>Initializes a vector for the angular metric.</li><li>Calculates the center of the grid.</li><li>Determines the size of each angular step in radians.</li><li>Iterates over each pixel in the grid and calculates the vector from the center to the pixel.</li><li>Calculates the angle of the vector and determines the corresponding sector.</li><li>Increments the count for the sector.</li><li>Adjusts the first and last sectors to account for discretization artifacts by taking their mean.</li><li>Returns the angular metric.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L288-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.area_gain-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><a class="docstring-binding" href="#TrypColonies.area_gain-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.area_gain</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">area_gain(agent_list::Vector{agent}, grids::Tuple{AbstractArray,AbstractArray}, para::parameters)</code></pre><p>Calculate the realtive gain in area walkable by agents in the grid.</p><p><strong>Arguments</strong></p><ul><li><code>agent_list::Vector{agent}</code>: A list of agents.</li><li><code>grids::Tuple{AbstractArray, AbstractArray}</code>: A tuple containing the grids.</li><li><code>para::parameters</code>: The parameters for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>area_gain::Float64</code>: The ratio of the current area covered by agents to the original area.</li></ul><p><strong>Description</strong></p><p>This function calculates the realtive gain in area covered by agents in the grid.      It compares the current area walkable by agents to the original area walkable by agents at the      start of the simulation. The original area is calculated using a newly created grid with the      same parameters, and the current area is calculated using the provided grid.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">agent_list = [...]  # List of agents
grids = (grid1, grid2)  # Tuple of grids
para = parameters(...)  # Simulation parameters
gain = area_gain(agent_list, grids, para)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L416-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.calc_path"><a class="docstring-binding" href="#TrypColonies.calc_path"><code>TrypColonies.calc_path</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Calculates reflection of agent on wall, calls itself up to 2 times recursivley if multiple reflections occur</p><p>#<img src="https://slidetodoc.com/presentation_image_h/ea91543057889988b7fa9402973b147a/image-11.jpg" alt="reflection_calculus"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L306-L311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.calc_repulsion-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TrypColonies.calc_repulsion-Tuple{Any, Any, Any}"><code>TrypColonies.calc_repulsion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calc_repulsion(all_list, index_rep, old_agent) -&gt; Vector{Float64}</code></pre><p>Calculates the hard repulsion vector for an agent based on the positions of other agents in its vicinity.      The function normalizes the repulsion vectors and sums them to determine the overall direction of repulsion.</p><p><strong>Arguments</strong></p><ul><li><code>all_list</code>: A list containing various attributes of all agents created by the function <code>find_neighbour_agents</code>.    The x and y positions of the agents are expected to be at indices 4 and 5, respectively.</li><li><code>index_rep</code>: A list of indices representing the agents that are considered for repulsion.</li><li><code>old_agent</code>: An agent struct containing the current direction of the agent (<code>dir_x</code> and <code>dir_y</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: A normalized vector representing the direction of repulsion. If no repulsion is detected, it returns the normalized direction of the <code>old_agent</code>.</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">all_list = [...]  # Assume this is a list containing agent attributes
index_rep = [1, 2, 3]  # Indices of agents to consider for repulsion
old_agent = Agent(1, 2, 0.5, 0.5)  # Assume this is an agent struct with direction fields
repulsion_vector = calc_repulsion(all_list, index_rep, old_agent)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L296-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.calculate_outgoing_vec-Tuple{TrypColonies.agent, Vector{Float64}}"><a class="docstring-binding" href="#TrypColonies.calculate_outgoing_vec-Tuple{TrypColonies.agent, Vector{Float64}}"><code>TrypColonies.calculate_outgoing_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculates outgoing path of incoming particle, using raytracing formular and generic conventions:  #<img src="https://slidetodoc.com/presentation_image_h/ea91543057889988b7fa9402973b147a/image-11.jpg" alt="reflection_calculus"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L266-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.chemotactic_alignment-Tuple{Any, Any, Any, Any, Any, Any, Any, parameters}"><a class="docstring-binding" href="#TrypColonies.chemotactic_alignment-Tuple{Any, Any, Any, Any, Any, Any, Any, parameters}"><code>TrypColonies.chemotactic_alignment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chemotactic_alignment(grad_x, grad_y, Y_pos, X_pos, X_dir, Y_dir, biggest_grad, para::parameters)</code></pre><p>Aligns the direction of an agent based on the chemotactic gradient.</p><p><strong>Arguments</strong></p><ul><li><code>grad_x</code>: The gradient of the chemical concentration in the x direction.</li><li><code>grad_y</code>: The gradient of the chemical concentration in the y direction.</li><li><code>Y_pos</code>: The y position of the agent.</li><li><code>X_pos</code>: The x position of the agent.</li><li><code>X_dir</code>: The x component of the agent&#39;s direction.</li><li><code>Y_dir</code>: The y component of the agent&#39;s direction.</li><li><code>biggest_grad</code>: The largest gradient value for normalization.</li><li><code>para::parameters</code>: A struct containing various parameters, including the scale factor.</li></ul><p><strong>Description</strong></p><p>This function aligns the direction of an agent based on the chemotactic gradient. It performs the following steps:</p><ol><li>Scales the agent&#39;s position based on the scale factor.</li><li>Ensures the scaled positions are not zero.</li><li>Calculates the gradient direction at the agent&#39;s position.</li><li>Computes the amplitude of the gradient and the angle between the agent&#39;s direction and the gradient direction.</li><li>Scales the angle by the amplitude of the gradient.</li><li>Constructs a rotation matrix based on the scaled angle.</li><li>Rotates the agent&#39;s direction using the rotation matrix.</li><li>Returns the new direction of the agent.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">grad_x = rand(10, 10)
grad_y = rand(10, 10)
Y_pos = 5
X_pos = 5
X_dir = 1.0
Y_dir = 0.0
biggest_grad = 1.0
para = parameters(pa_ph = pa_ph(scale_fac = 1.0))

chemotactic_alignment(grad_x, grad_y, Y_pos, X_pos, X_dir, Y_dir, biggest_grad, para)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L389-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.chose_interaction_radius-Tuple{parameters}"><a class="docstring-binding" href="#TrypColonies.chose_interaction_radius-Tuple{parameters}"><code>TrypColonies.chose_interaction_radius</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">chose_interaction_radius(parameters::parameters) -&gt; Float64</code></pre><p>Determines the interaction radius to be used based on the given parameters. If the <code>repulsion_flag</code> is set,  it compares the <code>repulsion_range</code> with the <code>interaction_radius</code> and returns the larger of the two.   If the <code>repulsion_flag</code> is not set, it simply returns the <code>interaction_radius</code>.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::parameters</code>: A struct containing the simulation parameters, including:<ul><li><code>repulsion_flag::Bool</code>: A flag indicating whether repulsion is considered.</li><li><code>repulsion_range::Int</code>: The range of repulsion.</li><li><code>interaction_radius::Int</code>: The default interaction radius.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Int64</code>: The chosen interaction radius based on the given parameters.</li></ul><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L187-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_buttons-Tuple{Makie.Figure, TrypColonies.Figure_observables, parameters, plot_parameters}"><a class="docstring-binding" href="#TrypColonies.create_buttons-Tuple{Makie.Figure, TrypColonies.Figure_observables, parameters, plot_parameters}"><code>TrypColonies.create_buttons</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_buttons(f::Figure, fig_obs::Figure_observables, Parameters::parameters) -&gt; (Button, Observable{parameters})</code></pre><p>Creates interactive UI elements, including a start/stop button and a grid of sliders, to control simulation parameters in a graphical figure.</p><p><strong>Arguments</strong></p><ul><li><code>f::Figure</code>: The main figure where the UI elements will be added.</li><li><code>fig_obs::Figure_observables</code>: An observable object that includes the running state of the simulation.</li><li><code>Parameters::parameters</code>: A struct containing the initial parameters for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>(Button, Observable{parameters})</code>: A tuple containing the start/stop button and an observable parameter struct that updates based on the slider values.</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">f = Figure()
fig_obs = Figure_observables(Isrunning = Observable(false))
Parameters = parameters(...)  # Assume this is the parameters struct with initial values
pause_button, para_obs = create_buttons(f, fig_obs, Parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Visu.jl#L168-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_data_path_vector-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.create_data_path_vector-Tuple{Any}"><code>TrypColonies.create_data_path_vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_data_path_vector(data_path) -&gt; Vector{String}</code></pre><p>Creates a vector of full data paths by reading the contents of the specified directory or directories, excluding certain files.</p><p><strong>Arguments</strong></p><ul><li><code>data_path</code>: A string representing a single directory path or a vector of directory paths.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: A vector of full paths to the data files in the specified directory or directories, excluding &quot;settings.csv&quot;, &quot;settings.jls&quot;, and &quot;analysis&quot;.</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">data_path = &quot;C:\data&quot;
full_data_paths = create_data_path_vector(data_path)

data_paths = [&quot;C:\data1&quot;, &quot;C:\data2&quot;]
full_data_paths = create_data_path_vector(data_paths)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_exp_scalar_grid-Tuple{parameters}"><a class="docstring-binding" href="#TrypColonies.create_exp_scalar_grid-Tuple{parameters}"><code>TrypColonies.create_exp_scalar_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_exp_scalar_grid(para::parameters) -&gt; Matrix{Float64}</code></pre><p>Creates a scalar grid based on a Gaussian distribution centered in the middle of the grid. The gradient values are calculated using the specified parameters.</p><p><strong>Arguments</strong></p><ul><li><code>para::parameters</code>: A struct containing the parameters for the grid, including:<ul><li><code>size::Tuple{Int, Int}</code>: The dimensions of the grid.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: A 2D array representing the gradient grid, with values following a Gaussian distribution.</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">parameters = parameters(size=(100, 100))
grad_grid = create_exp_scalar_grid(parameters)</code></pre><p>This function is useful for creating a scalar field that can be used in simulations where agents respond to spatial gradients, such as chemotaxis or other gradient-based behaviors. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L544-L563">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_grids-Tuple{parameters}"><a class="docstring-binding" href="#TrypColonies.create_grids-Tuple{parameters}"><code>TrypColonies.create_grids</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_grid(para::parameters) -&gt; Matrix{Int64}</code></pre><p>Create a grid based on the specified parameters. The function initializes a grid of zeros and modifies it according to  the geometry specified in <code>Parameters</code>. The grid can be shaped into a square, channel, circle, or a smaller circle, with negative values (defined by <code>Parameters.grid_strength</code>) in the entire grid except for the specified geometry shape.</p><p><strong>Arguments</strong></p><pre><code class="language-julia hljs">- `para::parameters`: A struct containing the grid parameters. It must have the following fields:
    - `size::Tuple{Int64, Int64}`: The dimensions of the grid.
    - `geometry::String`: The shape of the grid, which can be &quot;square&quot;, &quot;channel&quot;, &quot;circle&quot;, or &quot;circle_small&quot;.
    - `grid_strength::Int64`: The negative value to be applied to the grid&#39;s border or outside the specified shape.</code></pre><p><strong>Returns</strong></p><ul><li><code>Matrix{Int64}</code>: The generated grid with the specified geometry and dimensions.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">params = parameters(size=(100, 100), geometry=&quot;square&quot;, grid_strength=5)
grid = create_grid(params)</code></pre><p>This function supports creating grids with different geometries to simulate various environments or constraints. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L188-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_noise_dis-Tuple{parameters}"><a class="docstring-binding" href="#TrypColonies.create_noise_dis-Tuple{parameters}"><code>TrypColonies.create_noise_dis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">`create_noise_dis(parameters::parameters)`</code></pre><p>Create a noise distribution object based on the simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::parameters</code>: A struct containing the simulation parameters. This must include:<ul><li><code>noise_dis</code>: The type of distribution to use for noise. Expected to be either <code>Uniform</code> or <code>Normal</code>.</li><li><code>noise_strength</code>: A parameter (η) that defines the strength of the noise. For a <code>Uniform</code> distribution, it defines the range <code>[-η, η]</code>.      For a <code>Normal</code> distribution, it defines the standard deviation σ with a mean of 0.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li>A distribution object corresponding to the specified noise distribution and strength. If <code>noise_strength</code> is 0, </li></ul><p>it returns a <code>Normal</code> distribution with mean 0 and standard deviation 0.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">parameters = parameters(noise_dis=Uniform, noise_strength=0.5)
noise_distribution = create_noise_dis(parameters)
This will create a Uniform(-0.5, 0.5) distribution for noise.</code></pre><p><strong>Notes</strong></p><p>The function supports creating Uniform and Normal distributions based on the <code>noise_dis</code> parameter in <code>parameters</code>. If <code>noise_strength</code> (η) is set to 0, the function defaults to creating a Normal(0.0, 0.0) distribution,  effectively adding no noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L2-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_para_struct-Tuple{Dict}"><a class="docstring-binding" href="#TrypColonies.create_para_struct-Tuple{Dict}"><code>TrypColonies.create_para_struct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_para_struct(settings::Dict) -&gt; parameters::parameters</code></pre><p>Constructs a <code>parameters</code> struct from a dictionary of settings, dynamically generating the struct fields      and their values based on the input dictionary. This function uses metaprogramming to parse and evaluate a       string representation of the struct initialization.</p><p><strong>Arguments</strong></p><ul><li><code>settings::Dict</code>: A dictionary where keys are the names of the parameters (as symbols or strings) and values are the</li></ul><p>corresponding values for these parameters. The values can be of any type, including <code>String</code>.</p><p><strong>Returns</strong></p><ul><li>A new instance of the <code>parameters</code> struct with fields and values corresponding to the entries in the <code>settings</code> dictionary.</li></ul><p>If some keys are missing in the dictionary, the default values from the <code>parameters</code> struct definiton  will be used. </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">settings = Dict(:radius_collision =&gt; 2, :size =&gt; (10,))
para_struct = create_para_struct(settings)</code></pre><p>This will create an instance of the parameters struct with radius_collision set to 2, size set to (10,10).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Sweep_functions.jl#L2-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_para_struct_vec-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.create_para_struct_vec-Tuple{Any}"><code>TrypColonies.create_para_struct_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_para_struct_vec(data_used) -&gt; Vector{Vector{parameters}}</code></pre><p>Creates a vector of parameter structures from the given data. The function handles both 1-dimensional and 2-dimensional data inputs.</p><p><strong>Arguments</strong></p><ul><li><code>data_used</code>: The input data from which parameter structures are to be created. It can be a 1-dimensional or 2-dimensional array.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{parameters}}</code>: A vector of vectors, where each inner vector contains parameter structures created from the input data.</li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">data_used = DataFrame(...)  # Assume this is a DataFrame with the necessary data
para_vec = create_para_struct_vec(data_used)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L29-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_sweep_para_vec-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.create_sweep_para_vec-Tuple{Any}"><code>TrypColonies.create_sweep_para_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_sweep_para_vec(data_used::DataFrame) -&gt; Array{Array{Float64}}</code></pre><p>Generates a vector of sweep parameter vectors based on the input data.</p><p><strong>Arguments</strong></p><ul><li><code>data_used::DataFrame</code>: An DataFrame where each row contains the sweep parameter information, including the sweep parameter name, start value, increment, and number of steps.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Array{Float64}}</code>: A vector of vectors, where each inner vector contains the sweep parameter values for a specific row in the input data.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">data_used = Dataframe(
    (sweep_parameter=&quot;param1&quot;, param1=0.0, parameter_increment=0.1, parameter_steps=5,...),
    (sweep_parameter=&quot;param2&quot;, param2=1.0, parameter_increment=0.2, parameter_steps=3,...)
)
sweep_para_vec = create_sweep_para_vec(data_used)
# sweep_para_vec is now [[0.0, 0.1, 0.2, 0.3, 0.4], [1.0, 1.2, 1.4]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L61-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.create_veloctiy_dis-Tuple{parameters}"><a class="docstring-binding" href="#TrypColonies.create_veloctiy_dis-Tuple{parameters}"><code>TrypColonies.create_veloctiy_dis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_velocity_dis(parameters::parameters) -&gt; Distribution</code></pre><p>Creates a velocity distribution for agents based on the simulation parameters.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::parameters</code>: A struct containing the simulation parameters, which must include:<ul><li><code>velocity_dis</code>: The type of distribution to use (<code>Uniform</code> or <code>Normal</code>).</li><li><code>velocity_variance</code>: The variance of the velocity distribution.</li><li><code>velocity</code>: The mean velocity of the agents.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>Distribution</code>: A truncated distribution object representing the velocity distribution of agents.    The distribution is truncated at the lower bound of 0 to ensure that velocity values are non-negative.</li></ul><p><strong>Behavior</strong></p><ul><li>If both <code>velocity</code> and <code>velocity_variance</code> are 0, a <code>Normal</code> distribution with mean 0 and variance 0 is returned.</li><li>If <code>velocity_dis</code> is <code>Uniform</code>, a truncated <code>Uniform</code> distribution ranging from <code>(velocity - variance)</code> to <code>(velocity + variance)</code> is created.</li><li>If <code>velocity_dis</code> is <code>Normal</code>, a truncated <code>Normal</code> distribution with the specified mean (<code>velocity</code>) and variance (<code>velocity_variance</code>) is created.</li><li>The truncation ensures that the resulting velocity values are always non-negative, as negative velocities are not physically meaningful in this context.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">parameters = parameters(velocity_dis=Normal, velocity_variance=1.0, velocity=5.0)
velocity_distribution = create_velocity_dis(parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.cross_2d-Tuple{Vector{T} where T&lt;:Real, Vector{T} where T&lt;:Real}"><a class="docstring-binding" href="#TrypColonies.cross_2d-Tuple{Vector{T} where T&lt;:Real, Vector{T} where T&lt;:Real}"><code>TrypColonies.cross_2d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cross_2d(v1::Vector{&lt;:Real}, v2::Vector{&lt;:Real}) -&gt; Real</code></pre><p>Calculates the 2D cross product (also known as the perp product) of two 2D vectors.</p><p><strong>Arguments</strong></p><ul><li><code>v1::Vector{Real}</code>: The first 2D vector.</li><li><code>v2::Vector{Real}</code>: The second 2D vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>Real</code>: The scalar result of the 2D cross product.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">v1 = [1.0, 2.0]
v2 = [3.0, 4.0]
result = cross_2d(v1, v2)
# result is -2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L340-L359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.find_data_path-Tuple{}"><a class="docstring-binding" href="#TrypColonies.find_data_path-Tuple{}"><code>TrypColonies.find_data_path</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_data_path(data_paths; local=false) -&gt; String</code></pre><p>Finds and returns the path to the data directory. If <code>local</code> is set to <code>true</code>, it checks for a directory named &quot;data&quot; in the current working directory and returns the path specified by <code>data_paths[&quot;local_data&quot;]</code> if found. If <code>local</code> is <code>false</code> or the local &quot;data&quot; directory is not found, it iterates through the <code>data_paths</code> dictionary and returns the first path that corresponds to an existing directory.</p><p><strong>Arguments</strong></p><ul><li><code>data_paths::Dict{String,String}</code>: A dictionary where keys are descriptive names of the paths and values are the actual paths to data directories.</li><li><code>local::Bool=false</code> (optional): A flag to indicate whether to look for a local &quot;data&quot; directory first.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The path to the data directory that was found.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>local</code> is <code>true</code> but no local &quot;data&quot; directory is found.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data_paths = Dict(&quot;local_data&quot; =&gt; &quot;./data&quot;, &quot;remote_data&quot; =&gt; &quot;/mnt/data&quot;)
path = find_data_path(data_paths, local=true)</code></pre><p>This function is useful for applications that need to flexibly switch between local and remote data sources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Auxiliary.jl#L1-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.find_free_neighbour_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><a class="docstring-binding" href="#TrypColonies.find_free_neighbour_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><code>TrypColonies.find_free_neighbour_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_free_neighbour_points(grid::Matrix{Int64}, tryp::agent, Parameters::parameters) -&gt; Tuple{Bool, Int64, Int64}</code></pre><p>Finds a free neighboring point around a given agent&#39;s position in a grid, considering specified boundary conditions.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Matrix{Int64}</code>: A 2D grid representing the environment, where 0 indicates a free space and other values indicate occupied spaces.</li><li><code>tryp::agent</code>: An agent object with fields <code>x_pos</code> and <code>y_pos</code> indicating its current position in the grid.</li><li><code>Parameters::parameters</code>: A parameters object containing simulation parameters, including <code>boundary_conditions</code> which can be &quot;periodic&quot; and <code>size</code> indicating the size of the grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>sucess::Bool</code>: A boolean indicating whether a free neighboring point was found.</li><li><code>X_pos_new::Int64</code>: The x-coordinate of the found free neighboring point. Returns the agent&#39;s original x-coordinate if no free point is found.</li><li><code>Y_pos_new::Int64</code>: The y-coordinate of the found free neighboring point. Returns the agent&#39;s original y-coordinate if no free point is found.</li></ul><p><strong>Description</strong></p><p>This function attempts to find a free (unoccupied) neighboring point around the agent&#39;s current position. It randomly shuffles the directions to check for free spaces to ensure unbiased movement direction. If the <code>boundary_conditions</code> are set to &quot;periodic&quot;, it will apply periodic boundary corrections to wrap around the grid edges. The function returns whether a free space was found and the coordinates of that space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L403-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.find_neighbour_agents-NTuple{4, Any}"><a class="docstring-binding" href="#TrypColonies.find_neighbour_agents-NTuple{4, Any}"><code>TrypColonies.find_neighbour_agents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_neighbour_agents(parameters, agent_list, i, interaction_radius, grid) -&gt; Vector{Vector{Float64}}</code></pre><p>Finds the neighboring agents within a specified interaction radius for a given agent and returns their directional vectors, distances, and relative positions.</p><p><strong>Arguments</strong></p><ul><li><code>parameters</code>: A struct containing the simulation parameters, including boundary conditions and grid size.</li><li><code>agent_list</code>: A list of agents, where each agent has attributes such as <code>x_pos</code>, <code>y_pos</code>, <code>dir_x</code>, and <code>dir_y</code>.</li><li><code>i</code>: The index of the agent for which neighbors are being found.</li><li><code>interaction_radius</code>: The radius within which to search for neighboring agents.</li><li><code>grid</code>: A 2D array representing the grid, where each cell contains the index of an agent or 0 if the cell is empty.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Float64}}</code>: A vector containing five vectors:<ul><li><code>dir_x_list</code>: The x-components of the direction vectors of the neighboring agents.</li><li><code>dir_y_list</code>: The y-components of the direction vectors of the neighboring agents.</li><li><code>dist_list</code>: The distances from the given agent to each neighboring agent.</li><li><code>pos_x_list</code>: The x-coordinates of the neighboring agents relative to the given agent.</li><li><code>pos_y_list</code>: The y-coordinates of the neighboring agents relative to the given agent.</li></ul></li></ul><p><strong>Example Usage</strong></p><pre><code class="language-julia hljs">parameters = Parameters(boundary_conditions=&quot;periodic&quot;, size=(100, 100))
agent_list = [Agent(10, 10, 1.0, 0.0), Agent(12, 12, -1.0, 0.0)]  # Example agents
grid = zeros(Int64, 100, 100)
grid[10, 10] = 1
grid[12, 12] = 2
neighbors = find_neighbour_agents(parameters, agent_list, 1, 5, grid)

end</code></pre><p>This function is useful for simulations where agents interact with their neighbors within a certain radius, such as in flocking or swarming behaviors.  It calculates the direction vectors, distances, and relative positions of neighboring agents,  which can be used to update the agent&#39;s direction based on the interactions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Direction.jl#L223-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.find_right_tangent_points-Tuple{Vector{Vector{Int64}}}"><a class="docstring-binding" href="#TrypColonies.find_right_tangent_points-Tuple{Vector{Vector{Int64}}}"><code>TrypColonies.find_right_tangent_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Finds and returns the two most distant tangent points from a given array of tangent points.</p><p>This function is designed to process an array of tangent points, each represented as a <code>Vector{Int64}</code> containing two elements (coordinates). It calculates the pairwise distances between all points in the array using a helper function <code>length_vec</code> to determine the length of the vector formed by two points. The function then identifies and returns the pair of points that are the most distant from each other, which are considered the &quot;right&quot; tangent points for further processing.</p><p><strong>Arguments</strong></p><ul><li><code>tangent_points::Vector{Vector{Int64}}</code>: An array of points, each point is a vector of two integers representing its coordinates.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: An array containing the two most distant tangent points from the input array.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">tangent_points = [[1, 2], [3, 4], [5, 6]]
right_tangent_points = find_right_tangent_points(tangent_points)
# right_tangent_points will contain the two points that are furthest apart</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L187-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.find_surounding_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><a class="docstring-binding" href="#TrypColonies.find_surounding_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><code>TrypColonies.find_surounding_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns all grid points surrounding the collision point in a radius of r  The discretization going from the continuous circle to the discrete points on the grid is done with the stepwidth:  <code>steps</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L156-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.find_tangent_points-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><a class="docstring-binding" href="#TrypColonies.find_tangent_points-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}"><code>TrypColonies.find_tangent_points</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Reurn the gridpoints from the list of gridpoints in circle, which are the first ones of the boundary  by checking when there is a change in the value list of points from -1 to 0 or vice versa. The last gridpoint that has the  value -1 will be used as the probable point on the boundary between occupied and free space. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L222-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.foldersize"><a class="docstring-binding" href="#TrypColonies.foldersize"><code>TrypColonies.foldersize</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><strong><code>foldersize</code></strong></p><p>Calculates the size of a directory in megabytes. If <code>recursive</code> is set to <code>true</code>, it computes the total size by recursively summing the sizes of all files within the directory and its subdirectories. If <code>recursive</code> is <code>false</code>, it returns the size of the directory itself, which may not be meaningful as directories typically have a small, fixed size.</p><p><strong>Parameters:</strong></p><ul><li><code>dirpath::String = pwd()</code>: The path to the directory whose size is to be calculated.Defaults to the current working directory.</li><li><code>recursive::Bool = true</code>: A flag indicating whether the size calculation should be recursive. Defaults to <code>true</code>.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Float64</code>: The size of the directory in megabytes.</li></ul><p><strong>Example Usage:</strong></p><pre><code class="language-julia hljs">size = foldersize(&quot;/path/to/directory&quot;, recursive=true)</code></pre><p>This function is useful for monitoring disk usage by directories,      especially in applications where managing data storage is critical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Auxiliary.jl#L44-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.get_reflected_vec-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><a class="docstring-binding" href="#TrypColonies.get_reflected_vec-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}"><code>TrypColonies.get_reflected_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the normalized reflected vector from the tangent to the next boundary of a given grid point. Function includes a fallback  option, if no unambiguous tangent is defined by two points, the original orientation is just reversed.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L278-L281">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.initialize_system-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}"><a class="docstring-binding" href="#TrypColonies.initialize_system-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}"><code>TrypColonies.initialize_system</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize_system!(grids::Tuple{Matrix{Int64}, Matrix{Float64}}, Parameters::parameters)</code></pre><p>Initializes the simulation system by setting up the initial configuration of agents and grid states.</p><p><strong>Arguments</strong></p><ul><li><code>grids::Tuple{Matrix{Int64}, Matrix{Float64}}</code>: A tuple containing two matrices. The first matrix represents the grid to be initialized.</li><li><code>Parameters::parameters</code>: A struct containing various parameters, including the number of timesteps and other simulation parameters.</li></ul><p><strong>Description</strong></p><p>This function initializes the system by setting up the initial configuration of agents and grid states. It performs the following steps:</p><ol><li>Initializes an empty list of agents.</li><li>Creates a list to store the state of agents for each timestep.</li><li>Calls <code>random_start_config!</code> to set up the initial configuration of the grid and agents.</li><li>Copies the initial agent list to all timesteps.</li><li>Initializes a sparse matrix vector to save grid changes.</li><li>Saves the initial grid state to the sparse matrix vector.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">grids = (Matrix{Int64}(undef, 10, 10), Matrix{Float64}(undef, 10, 10))
Parameters = parameters(pa_ph = pa_ph(time_steps_to_compute = 100), timesteps = 100)

initialize_system(grids, Parameters)</code></pre><p><strong>Returns</strong></p><p>grids: The initialized grids. agent<em>list</em>full: A list of agent states for each timestep. grid<em>vec</em>sparse: A vector of sparse matrices to save grid changes. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L273-L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.length_vec-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#TrypColonies.length_vec-Tuple{Vector{Int64}}"><code>TrypColonies.length_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong><code>length_vec</code></strong></p><p>Calculates and returns the Euclidean length (magnitude) of a 2-dimensional vector represented by a <code>Vector{Int64}</code>.</p><p><strong>Parameters:</strong></p><ul><li><code>vec::Vector{Int64}</code>: A vector with two elements where <code>vec[1]</code> is the x-component and <code>vec[2]</code> is the y-component of the vector.</li></ul><p><strong>Returns:</strong></p><ul><li><code>Float64</code>: The Euclidean length of the vector.</li></ul><p><strong>Example Usage:</strong></p><pre><code class="language-julia hljs">vector = [3, 4]
length = length_vec(vector) # Returns 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Auxiliary.jl#L82-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.make_para_dict_list-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.make_para_dict_list-Tuple{Any}"><code>TrypColonies.make_para_dict_list</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_para_dict_list(sweep_dict_original::Dict)</code></pre><p>Generate a list of parameter dictionaries for simulation runs based on the original sweep parameters dictionary.</p><p><strong>Arguments</strong></p><ul><li><code>sweep_dict_original::Dict</code>: A dictionary containing the original sweep parameters. </li></ul><p>It must include keys for <code>sweep_parameter</code>, <code>parameter_steps</code>,  <code>iterations</code>, and <code>parameter_increment</code>. The <code>sweep_parameter</code> key should match one of the keys in the dictionary   that will be varied across simulations.</p><p><strong>Returns</strong></p><ul><li><code>Array{Dict}</code>: An array of dictionaries, each representing a set of parameters for a single simulation run.</li></ul><p>The specified sweep parameter is incremented across these dictionaries according to the <code>parameter_steps</code>   and <code>parameter_increment</code> specified in the original dictionary.</p><p><strong>Throws</strong></p><ul><li>An error if the <code>sweep_parameter</code> specified in <code>sweep_dict_original</code> does not exist in the dictionary keys.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sweep_dict_original = Dict(
    &quot;sweep_parameter&quot; =&gt; &quot;agent_number&quot;,
    &quot;parameter_steps&quot; =&gt; 5,
    &quot;iterations&quot; =&gt; 10,
    &quot;parameter_increment&quot; =&gt; 2,
    &quot;other_param&quot; =&gt; 1
)
para_dict_list = make_para_dict_list(sweep_dict_original)</code></pre><p>This function is useful for creating parameter sweeps for simulations,      where one wants to vary a single parameter across a range of values while keeping other parameters constant.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Sweep_functions.jl#L43-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.make_sys_interactive!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, Any}"><a class="docstring-binding" href="#TrypColonies.make_sys_interactive!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, Any}"><code>TrypColonies.make_sys_interactive!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong><code>make_sys_interactive!</code></strong></p><p>Transforms a grid system into an interactive one by initializing a circular buffer to store agent states, allowing for dynamic updates.</p><p><strong>Parameters:</strong></p><ul><li><code>grids</code>: The grids on which agents operate. This function does not modify the grid but returns it for consistency in the interface.</li><li><code>agent_list_full</code>: A list (vector) of agents. These agents are the initial state of the system.</li><li><code>buffer_length::Int=5</code> (optional): The length of the circular buffer. This determines how many past states of the agent list can be stored. Default is 5.</li></ul><p><strong>Returns:</strong></p><ul><li><code>grids</code>: The same grid passed as input, returned unchanged.</li><li><code>agent_list_cicular</code>: A circular buffer filled with deep copies of the first agent in <code>agent_list_full</code>.</li></ul><p>This buffer allows for storing and accessing past states of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L349-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.moving_avg"><a class="docstring-binding" href="#TrypColonies.moving_avg"><code>TrypColonies.moving_avg</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">moving_avg(X::Vector, numofele::Int=length(X)÷2)</code></pre><p>Calculates the moving average of a vector.</p><p><strong>Arguments</strong></p><ul><li><code>X::Vector</code>: The input vector for which the moving average is to be calculated.</li><li><code>numofele::Int</code>: The number of elements to consider for the moving average (default is half the length of <code>X</code>).</li></ul><p><strong>Description</strong></p><p>This function calculates the moving average of the input vector <code>X</code>. It performs the following steps:</p><ol><li>Determines the number of elements to look behind and ahead for the moving average.</li><li>Initializes an output vector <code>Y</code> of the same length as <code>X</code>.</li><li>Iterates over each element in <code>X</code> and calculates the moving average for a range of elements around it.</li><li>Stores the calculated moving average in the output vector <code>Y</code>.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">X = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numofele = 3

moving_avg(X, numofele)</code></pre><p><strong>Returns</strong></p><ul><li><code>Y::Vector</code>: The vector containing the moving average values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L524-L549">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.nearby_neighbours-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#TrypColonies.nearby_neighbours-Tuple{Any, Any, Any}"><code>TrypColonies.nearby_neighbours</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nearby_neighbours(Agent_list::Vector{agent}, Grid::AbstractArray, Parameters::parameters)</code></pre><p>Legacy function to calculate the number of nearby neighbours for each agent within a      specified interaction range as an heatmap to then calculate the      average nearby topology of an agent.</p><p><strong>Arguments</strong></p><ul><li><code>Agent_list::Vector{agent}</code>: A vector containing the agents.</li><li><code>Grid::AbstractArray</code>: The grid representing the simulation space.</li><li><code>Parameters::parameters</code>: A struct containing various parameters, including the interaction radius.</li></ul><p><strong>Description</strong></p><p>This function calculates the number of nearby neighbours for each agent within a specified interaction range. It performs the following steps:</p><ol><li>Initializes a sum grid to accumulate the number of neighbours.</li><li>Iterates over each agent and extracts a sub-grid around the agent&#39;s position within the interaction range.</li><li>Replaces positive values in the sub-grid with 1 and negative values with 0.</li><li>Sets the agent&#39;s own position in the sub-grid to 0.</li><li>Adds the sub-grid to the sum grid.</li><li>Returns the rotated sum grid.</li></ol><p><strong>Example</strong></p><p>```julia Agent<em>list = [agent(x</em>pos=5, y<em>pos=5), agent(x</em>pos=10, y<em>pos=10)] Grid = rand(-1:1, 20, 20) Parameters = parameters(interaction</em>radius=2)</p><p>nearby<em>neighbours(Agent</em>list, Grid, Parameters) Returns sum_grid: A grid representing the number of nearby neighbours for each agent. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L585-L615">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.path_tracing-Tuple{Matrix{Int64}, TrypColonies.agent, Any, parameters}"><a class="docstring-binding" href="#TrypColonies.path_tracing-Tuple{Matrix{Int64}, TrypColonies.agent, Any, parameters}"><code>TrypColonies.path_tracing</code></a> — <span class="docstring-category">Method</span></summary><section><div><ul><li><strong>Function Name</strong>: <code>path_tracing</code></li><li><strong>Description</strong>: This function simulates the movement of an agent (<code>tryp</code>) through a grid, step by step, to determine the point at which it first encounters a wall. It returns the X and Y positions on the grid where the first wall is encountered, along with the distance already walked.</li><li><strong>Parameters</strong>:<ul><li><code>grid::Matrix{Int64}</code>: The grid through which the agent moves, represented as a matrix of integers.</li><li><code>tryp::agent</code>: The agent attempting to move through the grid. It contains properties like direction (<code>dir_x</code>, <code>dir_y</code>) and position (<code>x_pos</code>, <code>y_pos</code>).</li><li><code>velocity</code>: The speed at which the agent attempts to move through the grid.</li><li><code>parameters::parameters</code>: Additional parameters affecting the simulation, such as boundary conditions.</li></ul></li><li><strong>Returns</strong>: The function returns a tuple containing the X and Y indices of the first wall grid point encountered and the remaining distance the agent can walk.</li><li><strong>Algorithm</strong>:<ol><li>Initialize the agent&#39;s direction and position.</li><li>Iterate through the steps based on the agent&#39;s velocity.</li><li>Update the agent&#39;s position at each step, rounding to the nearest grid point.</li><li>If periodic boundary conditions are specified, adjust the position accordingly.</li><li>Check if the current grid point is a wall (<code>grid[Y_step_i, X_step_i] &lt; 0</code>). If so, move the agent back to the previous position and adjust for periodic boundary conditions if necessary.</li><li>Return the final position and the distance walked before encountering the wall.</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L98-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.periodic_boundary_correction-Tuple{Int64, Int64, Tuple{Int64, Int64}}"><a class="docstring-binding" href="#TrypColonies.periodic_boundary_correction-Tuple{Int64, Int64, Tuple{Int64, Int64}}"><code>TrypColonies.periodic_boundary_correction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">periodic_boundary_correction(x_pos::Int64, y_pos::Int64, size::Tuple{Int64,Int64}) -&gt; Tuple{Int64, Int64}</code></pre><p>Corrects the positions <code>(x_pos, y_pos)</code> of an object within a 2D grid to ensure they fall within the grid&#39;s boundaries, assuming periodic boundary conditions. This means that if an object moves beyond one edge of the grid, it re-enters the grid from the opposite edge, similar to a toroidal (doughnut-shaped) space.</p><p><strong>Arguments</strong></p><ul><li><code>x_pos::Int64</code>: The x-coordinate of the object&#39;s position.</li><li><code>y_pos::Int64</code>: The y-coordinate of the object&#39;s position.</li><li><code>size::Tuple{Int64,Int64}</code>: A tuple representing the size of the grid, where the first element is the width (x dimension) and the second element is the height (y dimension).</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Int64, Int64}</code>: The corrected position of the object as a tuple of <code>(x_pos, y_pos)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Given a grid of size 10x10
grid_size = (10, 10)

# An object at position (11, 5) would wrap around to (1, 5)
periodic_boundary_correction(11, 5, grid_size) # returns (1, 5)

# An object at position (0, 10) would wrap around to (10, 10)
periodic_boundary_correction(0, 10, grid_size) # returns (10, 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L46-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.radial_density_c-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><a class="docstring-binding" href="#TrypColonies.radial_density_c-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.radial_density_c</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">radial_density_c(agent_list::Vector{agent}, grids::Tuple{AbstractArray,AbstractArray}, para::parameters)</code></pre><p>Calculate the radial density of agents in a grid.</p><p><strong>Arguments</strong></p><ul><li><code>agent_list::Vector{agent}</code>: A list of agents.</li><li><code>grids::Tuple{AbstractArray, AbstractArray}</code>: A tuple containing the grids.</li><li><code>para::parameters</code>: The parameters for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li><code>dist_vec_equal_oc::Vector{Float64}</code>: A vector representing the normalized radial density of agents.</li></ul><p><strong>Description</strong></p><p>This function calculates the radial density of agents in a grid by comparing all possible available      grid points where agents can be with the points where they actually are.       It sorts these points by their distance from the center of the grid and normalizes the        counts of these distances to provide a radial density distribution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">agent_list = [...]  # List of agents
grids = (grid1, grid2)  # Tuple of grids
para = parameters(...)  # Simulation parameters
density = radial_density_c(agent_list, grids, para)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L469-L495">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.radial_distribution-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><a class="docstring-binding" href="#TrypColonies.radial_distribution-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}"><code>TrypColonies.radial_distribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">radial_distribution(agent_list::Vector{agent}, size::Tuple{Int, Int})</code></pre><p>Calculates the radial distribution of agents from the center of the grid.</p><p><strong>Arguments</strong></p><ul><li>agent_list::Vector{agent} : A vector of agent objects.</li><li><code>size::Tuple{Int, Int}</code>: A tuple containing the dimensions of the grid.</li></ul><p><strong>Description</strong></p><p>This function calculates the radial distribution of agents from the center of the grid. It performs the following steps:</p><ol><li>Calculates the center of the grid.</li><li>Computes the relative positions of the agents with respect to the center.</li><li>Calculates the Euclidean distance of each agent from the center.</li><li>Bins the distances and normalizes by 1/(2r+1) to get the radial distribution.</li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">x_pos = [1, 3, 5, 7]
y_pos = [2, 4, 6, 8]
size = (10, 10)

radial_distribution(x_pos, y_pos, size)</code></pre><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: The radial distribution </li><li><code>Vector{Float}</code>:   The distance vector, useable for histogram plotting    </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Analysis.jl#L217-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.reconstruct_grid!-Tuple{Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}, Int64, AbstractArray{Int64}}"><a class="docstring-binding" href="#TrypColonies.reconstruct_grid!-Tuple{Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}, Int64, AbstractArray{Int64}}"><code>TrypColonies.reconstruct_grid!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reconstruct_grid!(Grid_vec_sparse::Vector{SparseMatrixCSC{Int64, Int64}}, Timestep::Int, start_grid::AbstractArray{Int})</code></pre><p>Update <code>start_grid</code> in-place by adding the non-zero values from a specific timestep&#39;s sparse matrix in <code>Grid_vec_sparse</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Grid_vec_sparse</code>: A vector of sparse matrices (<code>SparseMatrixCSC{Int64, Int64}</code>), each representing the grid at a different timestep.</li><li><code>Timestep</code>: The specific timestep (index into <code>Grid_vec_sparse</code>) from which to take the non-zero values.</li><li><code>start_grid</code>: An array to be updated in-place. It represents the grid before updating, and it will be modified to include the non-zero values from the specified timestep&#39;s sparse matrix.</li></ul><p><strong>Description</strong></p><p>This function iterates over all non-zero elements of the sparse matrix at the specified <code>Timestep</code> in <code>Grid_vec_sparse</code>. For each non-zero element, it increments the corresponding element in <code>start_grid</code> by the value of the non-zero element. This operation modifies <code>start_grid</code> in-place, effectively reconstructing or updating the grid state by applying the changes from the specified timestep.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example usage
Grid_vec_sparse = [sparse([1, 2], [1, 2], [1, 1]), sparse([1, 2], [1, 2], [2, 2])]
Timestep = 2
start_grid = zeros(Int, 2, 2)

reconstruct_grid!(Grid_vec_sparse, Timestep, start_grid)
# start_grid is now [0 2; 0 2] (2x2 matrix of integers</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L397-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.reconstruct_grid_from_scratch"><a class="docstring-binding" href="#TrypColonies.reconstruct_grid_from_scratch"><code>TrypColonies.reconstruct_grid_from_scratch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reconstruct_grid_from_scratch(Grid_vec_sparse::Vector{SparseMatrixCSC{Int64, Int64}}, Timestep::Int = length(Grid_vec_sparse)) -&gt; Matrix{Int64}</code></pre><p>Reconstructs the grid state from scratch up to a specified timestep using a sequence of sparse matrices.</p><p><strong>Arguments</strong></p><ul><li><code>Grid_vec_sparse</code>: A vector of <code>SparseMatrixCSC{Int64, Int64}</code> objects, each representing the grid changes at a specific timestep.</li><li><code>Timestep</code>: (Optional) The timestep up to which the grid should be reconstructed. Defaults to the last available timestep in <code>Grid_vec_sparse</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>Matrix{Int64}</code> representing the reconstructed grid state up to the specified timestep.</p><p><strong>Description</strong></p><p>This function reconstructs the grid state by starting with the grid state at the first timestep      and then applying changes from each subsequent timestep up to the specified <code>Timestep</code>.       It uses the <code>reconstruct_grid!</code> function to apply changes in-place to the grid state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L429-L446">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.remove_fields_dict!-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.remove_fields_dict!-Tuple{Any}"><code>TrypColonies.remove_fields_dict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_fields_dict(dict::Dict{String, Any}) -&gt; Dict{String, Any}</code></pre><p>Removes keys from the given dictionary <code>dict</code> that are not present in the <code>parameters</code> structure.</p><p><strong>Arguments</strong></p><ul><li><code>dict::Dict{String, Any}</code>: The dictionary from which keys will be removed.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String, Any}</code>: The modified dictionary with only the keys that are present in the <code>parameters</code> structure.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">parameters = (a=1, b=2)
dict = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 3)
new_dict = remove_fields_dict(dict)
# new_dict is now Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)</code></pre><p>This function is useful for ensuring that a dictionary contains only valid keys before using it to set parameters in a simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Sweep_functions.jl#L108-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.res_scaling-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.res_scaling-Tuple{Any}"><code>TrypColonies.res_scaling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">res_scaling(image_number; factor::Real = 3.0, plots::Int = 1)</code></pre><p>Calculate the scaled width and height of an image based on the given factor and number of plots.</p><p><strong>Arguments</strong></p><ul><li><code>image_number::Int</code>: The number of the image to be scaled.</li><li><code>factor::Real</code>: The scaling factor for the image dimensions. Default is 3.0.</li><li><code>plots::Int</code>: The number of plots to be considered in the width calculation. Default is 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>width::Int</code>: The scaled width of the image.</li><li><code>height::Int</code>: The scaled height of the image.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">width, height = res_scaling(10, factor=2.5, plots=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Visu.jl#L440-L458">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.save_grid_changes!-Tuple{Matrix{Int64}, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}"><a class="docstring-binding" href="#TrypColonies.save_grid_changes!-Tuple{Matrix{Int64}, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}"><code>TrypColonies.save_grid_changes!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_grid_changes!(Grid_1::Union{Matrix{Int64}, Real}, Grid_2::Matrix{Int64}, Grid_vec::Vector{SparseMatrixCSC{Int64, Int64}})</code></pre><p>Subtracts <code>Grid_1</code> from <code>Grid_2</code> and appends the result to <code>Grid_vec</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Grid_1</code>: A matrix of integers or a real number. Represents the initial state of the grid.</li><li><code>Grid_2</code>: A matrix of integers. Represents the updated state of the grid.</li><li><code>Grid_vec</code>: A vector of sparse integer matrices. This vector is updated with the changes.</li></ul><p><strong>Notes</strong></p><ul><li>This function modifies <code>Grid_vec</code> in place by appending the difference between <code>Grid_2</code> and <code>Grid_1</code>.</li><li>If <code>Grid_1</code> is a real number, it is subtracted from each element of <code>Grid_2</code> before the result is appended to <code>Grid_vec</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L456-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.scale_color_map-Tuple{Any, Any}"><a class="docstring-binding" href="#TrypColonies.scale_color_map-Tuple{Any, Any}"><code>TrypColonies.scale_color_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>This function counteracts the dynamic scaling of colormaps in Makie if min and max values change over the course of an animation. It is given a Max value (min value = 0) and shrinks the colormap dynamically if the data does not reach the max value. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Visu.jl#L63-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.scale_time_step-Tuple{Any, Any}"><a class="docstring-binding" href="#TrypColonies.scale_time_step-Tuple{Any, Any}"><code>TrypColonies.scale_time_step</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale_time_step(dt_diff::Float64, dt_walker::Float64) -&gt; Tuple{Float64, Float64}</code></pre><p>Scales the time step <code>dt_diff</code> to be compatible with <code>dt_walker</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dt_diff::Float64</code>: The differential time step.</li><li><code>dt_walker::Float64</code>: The walker time step.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Float64, Float64}</code>: A tuple containing the scaled <code>dt_diff</code> and the original <code>dt_walker</code>.</li></ul><p><strong>Description</strong></p><p>This function adjusts the differential time step <code>dt_diff</code> to ensure it is compatible with the walker time step <code>dt_walker</code>. If <code>dt_diff</code> is greater than or equal to <code>dt_walker</code>, it is set to <code>dt_walker</code>. Otherwise, it is adjusted to be a divisor of <code>dt_walker</code> with a tolerance for floating-point precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L141-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.strenghten_boundary!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}"><a class="docstring-binding" href="#TrypColonies.strenghten_boundary!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}"><code>TrypColonies.strenghten_boundary!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">strenghten_boundary!(grids::Tuple{Matrix{Int64}, Matrix{Float64}}, Parameters::parameters)</code></pre><p>Strengthens the boundary of the grid by recovering the grid values based on a recovery rate.</p><p><strong>Arguments</strong></p><ul><li><code>grids::Tuple{Matrix{Int64}, Matrix{Float64}}</code>: A tuple containing two matrices. The first matrix represents the grid to be strengthened.</li><li><code>Parameters::parameters</code>: A struct containing various parameters, including grid size, recovery rate, and grid strength.</li></ul><p><strong>Description</strong></p><p>This function iterates over the grid and increases the grid values that are negative but greater than the negative grid strength.      The increase is determined by a Poisson distribution with a mean equal to the grid recovery rate.       If the updated grid value exceeds the negative grid strength, it is capped at the negative grid strength.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">grids = (Matrix{Int64}(undef, 10, 10), Matrix{Float64}(undef, 10, 10))
Parameters = parameters(size = (10, 10), grid_recover_rate = 0.1, grid_strength = 5)

strenghten_boundary!(grids, Parameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L476-L497">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.sweep_and_save_parallel_t"><a class="docstring-binding" href="#TrypColonies.sweep_and_save_parallel_t"><code>TrypColonies.sweep_and_save_parallel_t</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sweep_and_save_parallel_t(para_dict_list, full_data_path, offset=100000; threads=4)</code></pre><p>Run simulations in parallel and save the results.</p><p><strong>Arguments</strong></p><ul><li><code>para_dict_list::Vector{Dict}</code>: A list of parameter dictionaries for each simulation.</li><li><code>full_data_path::String</code>: The path where the simulation data will be saved.</li><li><code>offset::Int</code>: An offset for the file naming of the saved data. Default is 100000.</li><li><code>threads::Int</code>: The number of threads to use for parallel execution. Default is 4.</li></ul><p><strong>Description</strong></p><p>This function runs multiple simulations in parallel using the specified number of threads.      Each simulation is initialized with parameters from <code>para_dict_list</code>.      The simulation involves updating grids and agent lists over a series of time steps.      Data is sampled at specified intervals and stored in vectors.      After the simulation, the data is serialized and saved to <code>full_data_path</code> with filenames      based on the task index and offset.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">para_dict_list = [...]  # List of parameter dictionaries
full_data_path = &quot;path/to/save/data&quot;
sweep_and_save_parallel_t(para_dict_list, full_data_path, offset=100000, threads=4) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Sweep_functions.jl#L140-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.update_grid!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}"><a class="docstring-binding" href="#TrypColonies.update_grid!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}"><code>TrypColonies.update_grid!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_grid!(grid::Matrix{Int}, Parameters::parameters, grid_t::Matrix{Int}, grid_vec_sparse::Vector{SparseMatrixCSC{Int64, Int64}})</code></pre><p>Updates the simulation grid by strengthening boundaries and saving grid changes.</p><p><strong>Arguments</strong></p><ul><li><code>grid</code>: The current state of the simulation grid as a matrix of integers.</li><li><code>Parameters</code>: A struct containing simulation parameters, such as grid size and boundary strength.</li><li><code>grid_t</code>: A reference grid state used for comparison when saving changes.</li><li><code>grid_vec_sparse</code>: A vector of sparse matrices where changes to the grid are stored.</li></ul><p><strong>Description</strong></p><p>This function performs two main operations on the simulation grid:</p><ol><li>It calls <code>strengthen_boundary!</code> to modify the grid&#39;s boundaries based on the <code>Parameters</code>. This typically involves making the boundaries more negative (stronger) according to a predefined strength parameter.</li><li>It calls <code>save_grid_changes!</code> to compare the current grid state (<code>grid</code>) with a reference state (<code>grid_t</code>) and records the differences in <code>grid_vec_sparse</code>. This step is crucial for tracking the evolution of the grid over time in an efficient manner.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Agent_grid.jl#L519-L534">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.update_position!"><a class="docstring-binding" href="#TrypColonies.update_position!"><code>TrypColonies.update_position!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_position!(grid::Matrix{Int64}, full_agent_list, Parameters::parameters, timestep=1)</code></pre><p>Updates the positions of agents on a grid based on their velocities and directions.</p><p><strong>Arguments</strong></p><ul><li><code>grid::Matrix{Int64}</code>: A 2D grid representing the environment where each cell can be empty (0), occupied by an agent (positive non-zero) or part of unmoveable space (negative non-zero).</li><li><code>full_agent_list</code>: A collection of agents. Can be a <code>CircularBuffer{Vector{agent}}</code> for interactive/infinite simulations or a simple <code>Vector{agent}</code> for static/finite simulations.</li><li><code>Parameters::parameters</code>: A struct containing simulation parameters, including velocity distribution, boundary conditions, and whether path tracing is enabled.</li><li><code>timestep=1</code>: The current timestep of the simulation. Defaults to 1.</li></ul><p><strong>Behavior</strong></p><ul><li>Determines the velocity distribution for agents based on the provided parameters.</li><li>Draws a random velocity for each agent from the distribution. </li><li>Decides on the agent list to use based on the type of simulation (interactive/infinite vs. static/finite).</li><li>Iterates through each agent, calculating their new position based on their velocity and direction.</li><li>If <code>path_tracing</code> is disabled, agents move directly to their new position if it&#39;s empty, respecting boundary conditions.</li><li>If <code>path_tracing</code> is enabled, calculates a path for the agent and moves them along this path and interacts with the non movable space,    also respecting boundary conditions and handling sliding boundary conditions if enabled.</li><li>Updates the grid to reflect the new positions of the agents.</li><li>Updates the non movable space if the boundary is moveable.</li></ul><p><strong>Note</strong></p><ul><li>This function modifies the <code>grid</code> and <code>full_agent_list</code> in place.</li><li>Agents are assumed to be immutable; thus, to update an agent&#39;s position, a new agent with the updated position is created and replaced in the list.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Position.jl#L479-L504">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TrypColonies.@h-Tuple{Any}"><a class="docstring-binding" href="#TrypColonies.@h-Tuple{Any}"><code>TrypColonies.@h</code></a> — <span class="docstring-category">Macro</span></summary><section><div><p>@h methodname</p><p>Outputs documentations in jupyternotenbooks in VScode as markdown without bugs.</p><p>Example of how to use the <code>@h</code> macro:</p><pre><code class="language-julia hljs">@h res_scaling</code></pre><p>Outputs documentations in jupyternotenbooks in VScode as markdown without bugs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AndreasKuhn-ak/2026-Kuhn-et-al/blob/cf6097daec5173105e92440663a319ba98a3af7c/src/Auxiliary.jl#L105-L115">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 22 January 2026 15:38">Thursday 22 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"#TrypColonies","page":"Home","title":"TrypColonies","text":"Documentation for TrypColonies.\n\n","category":"section"},{"location":"#TrypColonies.Figure_observables","page":"Home","title":"TrypColonies.Figure_observables","text":"mutable struct Figure_observables\n\nA structure to hold various observables for visualizing simulation data.\n\nFields\n\nTime::Observable{Int64}: An observable for the current time step.\nV_a::Observable{CircularBuffer{Point2f}}: An observable for a circular buffer of 2D points represent a correlation function.\nV_a_length::Observable{Int64}: An observable for the length of V_a.\nX::Observable{Vector{Float64}}: An observable for the x-coordinates of agents.\nY::Observable{Vector{Float64}}: An observable for the y-coordinates of agents.\nU::Observable{Vector{Float64}}: An observable for the x-components of agent velocities.\nV::Observable{Vector{Float64}}: An observable for the y-components of agent velocities.\nN::Observable{Int64}: An observable for the number of agents.\nGrid_contour::Observable{Matrix{Int64}}: An observable for the grid which the agents move on.\nTheta::Observable{Vector{Float64}}: An observable for the angles of agents.\nIsrunning::Observable{Bool}: An observable to indicate if the simulation is running.\nColor_scaled: An observable for the scaled color values to make non-dynamic or dynamic colorscaling possible.\n\n\n\n\n\n","category":"type"},{"location":"#TrypColonies.agent","page":"Home","title":"TrypColonies.agent","text":"agent\n\nA struct representing an agent in a grid. It holds the agent's current position in the grid as well as its direction of movement.\n\nFields\n\nx_pos::Int64: The x-coordinate of the agent's position in the grid.\ny_pos::Int64: The y-coordinate of the agent's position in the grid.\ndir_x::Float64: The x-component of the agent's direction vector.\ndir_y::Float64: The y-component of the agent's direction vector.\n\n\n\n\n\n","category":"type"},{"location":"#TrypColonies.parameters","page":"Home","title":"TrypColonies.parameters","text":"parameters\n\nDefines the parameters for the simulation with default values and possible options for certain fields.\n\nFields\n\npa_ph::parameters_physical: A struct containing physical parameters for the simulation.\ninteraction_radius::Int64: The radius within which agents interact. Default is 7.\nboundary_conditions::String: The type of boundary conditions. Default is \"periodic\".\ngeometry::String: The geometry of the simulation area. Default is \"circle\".\nstart_config::String: The initial configuration of agents. Default is \"random\".\nstart_config_gradient::String: The initial configuration of the gradient. Default is \"random\".\nboundary_moveable::Bool: Whether the boundary is moveable. Default is true.\npath_tracing::Bool: Whether to trace the path of agents. Default is true.\nsliding_movement::Bool: Whether the boundary allows sliding. Default is false.\nrepulsion_flag::Bool: Whether repulsion is enabled. Default is false.\nrepulsion_range::Int64: The range of repulsion. Default is 3.\nchemotaxis_flag::Bool: Whether chemotaxis is enabled. Default is true.\nsize::Tuple{Int, Int}: The dimensions of the simulation grid. Default is pa_ph.N_abm.\nxc_w::LinRange{Float64, Int64}: A linear range of x coordinates for the grid.\nyc_w::LinRange{Float64, Int64}: A linear range of y coordinates for the grid.\narrow_to_grid_fac_x::Float64: The scaling factor for x coordinates from arrows to grid.\narrow_to_grid_fac_y::Float64: The scaling factor for y coordinates from arrows to grid.\nvelocity::Float64: The initial velocity of agents. Default is pa_ph.walker_step_size.\ntimesteps::Int64: The number of timesteps the simulation runs. Default is calculated from pa_ph.total_time and pa_ph.Δt_walker.\nvelocity_variance::Float64: The variance in agent velocities. Default is pa_ph.walker_step_size * pa_ph.velo_var_relative.\ngrowth_rate::Float64: The growth rate. Default is pa_ph.growth_rate.\n\nUsage Notes\n\nUse reflective boundary conditions only when agents cannot leave the grid space; otherwise, the simulation may crash silently.\nThe geometry field allows for simulating different environmental layouts, which can significantly affect agent behavior and interactions.\nThe start_config field determines the initial placement of agents, which can influence the dynamics of the simulation from the outset.\n\nThis struct is used to configure and initialize the simulation environment, affecting how agents move, interact, and evolve over time.\n\n\n\n\n\n","category":"type"},{"location":"#TrypColonies.parameters_physical","page":"Home","title":"TrypColonies.parameters_physical","text":"parameters_physical\n\nA struct representing the physical parameters for a simulation involving walkers and diffusion processes. This struct is initialized with default values and includes various fields related to the simulation's spatial and temporal properties.\n\nFields\n\nN::Tuple{Int, Int}: The number of grid points in the x and y directions in the gradient grid. Default is (1000, 1000).\nscale_fac::UInt: The scaling factor between the gradient grid where the diffusion is calculated and the one of the ABM. Default is 4.\nL::Tuple{Float64, Float64}: The physical dimensions of the simulation domain in the x and y directions. Default is (0.015, 0.015).\nagent_number::Int64: The number of agents in the simulation. Default is 250000.\nwalker_speed_phy::Float64: The physical speed of the walkers in m/s. Default is 5*10^-6.\nDiff_coe::Float64: The diffusion coefficient in m^2/s. Default is 7*10^-10.\ntotal_time::Float64: The total simulation time in s. Default is 200.0.\ngrowth_rate::Float64: The growth rate in 1/s. Default is 1.157*10^-5.\nwalker_step_size::Int: The step size for the walkers on the ABM grid. Default is 3.\ndecay_rate::Float64: The decay rate in 1/s. Default is 0.001.\nadsorption_rate::Float64: The adsorption rate/amount in 1/s . Default is 0.001.\nDiameter_colony::Float64: The diameter of the colony in m. Default is 0.003.\nnoise_dis::Any: The distribution for noise. Default is Normal.\nnoise_strength::Number: The stdd of the noise distribution. Default is 0.5.\nvelocity_dis::Any: The distribution for velocity. Default is Normal.\nvelo_var_relative::Float64: The relative variance in velocity. Default is 1.5.\ngrid_strength::Int64: The strength of the grid. Default is 100.\ngrid_recover_rate::Float64: The recovery rate of the grid. Default is 10.0.\nradius_tanget::Int64: The radius to calculate the tangent which is needed to calculate the reflection on walls. Default is 6.\nradius_collision::Int64: The radius for collision interactions. Default is 5.\nN_abm::Tuple{Int, Int}: The number of grid points in the ABM grid, calculated as N .* scale_fac.\ndx::Float64: The grid spacing in the x direction, calculated as L[1]/N[1].\ndy::Float64: The grid spacing in the y direction, calculated as L[2]/N[2].\nxc::LinRange{Float64, Int64}: A linear range of x coordinates from 0.0 to L[1] with N[1] points.\nyc::LinRange{Float64, Int64}: A linear range of y coordinates from 0.0 to L[2] with N[2] points.\nΔt_diff_min::Float64: The minimum time step for diffusion, calculated as (minimum((L./(N)))^2*2)/(8*Diff_coe+minimum((L./(N)))^2*decay_rate) (see Von Neumann stability analysis).\nΔt_walker_min::Float64: The minimum time step for walkers, calculated as (minimum((L./(N_abm)))*walker_step_size)/walker_speed_phy.\nΔt_diff::Float64: The time step for diffusion, calculated using scale_time_step.\nΔt_walker::Float64: The time step for walkers, calculated using scale_time_step.\nratio_walker_diff::Int: The ratio of walker time steps to diffusion time steps, calculated using scale_time_step.\ntime_steps_to_compute::Int: The total number of time steps to compute, calculated as round(Int, total_time/Δt_diff).\n\n\n\n\n\n","category":"type"},{"location":"#TrypColonies.plot_parameters","page":"Home","title":"TrypColonies.plot_parameters","text":"plot_parameters\n\nA structure defining parameters for plotting with default values.\n\nFields\n\nframerate: The number of frames per second in the animation. Default is 60.\ntheme: The plotting theme, using Attributes. Default is theme_ggplot2().\nfontsize: The font size for text elements. Default is 22.\narrow_tip_size: The size of the arrow tips. Default is 12.\narrow_tail_length: The length of the arrow tails. Default is 5.\nrefresh_delay: The delay between refreshes in seconds. Default is 0.05.\nres: The resolution of the plot as a tuple (width, height). Default is (1400, 2000).\nColor_arrows: The color scheme for arrows. Default is the full range of ColorSchemes.hsv.\nColor_heatmap: The color scheme for heatmaps. Default is indices 50 to 100 of ColorSchemes.bone.\ntimesteps_corfunc: The number of timesteps for the correlation function. Default is 100.\ncor_func: The correlation function for circles. Default is order_parameter_circle.\n\nUsage\n\nThis struct is used to configure the visual aspects and functionalities of plots, including animations, color schemes, and correlation calculations.\n\n\n\n\n\n","category":"type"},{"location":"#TrypColonies.adsorb!","page":"Home","title":"TrypColonies.adsorb!","text":"adsorb!(grids::Tuple{Matrix{Int64}, Matrix{Float64}}, full_agent_list, para::parameters, time_step::Int64 = 1)\n\nUpdates the gradient grid based on the positions of agents and their adsorption rates.\n\nArguments\n\ngrids::Tuple{Matrix{Int64}, Matrix{Float64}}: A tuple containing two matrices.    The second matrix represents the concentration of a chemical.\nfull_agent_list: A list of agents, which can be either a CircularBuffer of vectors of agents    or a vector of vectors of agents.\npara::parameters: A struct containing various parameters, including adsorption rate and    time step for the agents.\ntime_step::Int64: The current time step (default is 1).\n\nDescription\n\nThis function updates the gradient grid by increasing the concentration  at the positions of the agents.      The amount of increase is determined by the adsorption rate and the time step specified in the para parameter.\n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.ana_order_para_circle-Tuple{Any, parameters}","page":"Home","title":"TrypColonies.ana_order_para_circle","text":"ana_order_para_circle(data, para::parameters; time_steady::Float64=0.7) -> Float64\n\nCalculates the average order parameter over a specified steady-state period.\n\nArguments\n\ndata::save_model_data: An tuple contain an array as first element where each array element represents data points over time.\npara::parameters: A structure containing parameters required for the order_parameter_circle function.\ntime_steady::Float64: A fraction of the total time steps to consider as the steady-state period (default is 0.7).\n\nReturns\n\nFloat64: The average order parameter over the steady-state period.\n\nExample\n\ndata = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]\npara = parameters(...)\nresult = ana_order_para_circle(data, para)\n# result is the average order parameter over the steady-state period\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.ana_order_para_vicsek-Tuple{Any, parameters}","page":"Home","title":"TrypColonies.ana_order_para_vicsek","text":"ana_order_para_vicsek(data, para::parameters; time_steady=0.7) -> Float64\n\nCalculates the average order parameter for the Vicsek model over the steady-state period of the simulation.\n\nArguments\n\ndata: A collection of data points, where data[1] contains the time series data for which the order parameter is to be calculated.\npara::parameters: A struct containing the parameters required by the order_parameter function.\ntime_steady::Float64=0.7 (optional): The fraction of the total time steps to be considered as the steady-state period. Default is 0.7.\n\nReturns\n\nFloat64: The average order parameter over the steady-state period.\n\nExample Usage\n\ndata = [...]  # Assume this is the data collected from the simulation\npara = parameters(...)  # Assume this is the parameters struct\naverage_order = ana_order_para_vicsek(data, para, time_steady=0.8)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.angle_between_vec-Tuple{Vector{<:Real}, Vector{<:Real}}","page":"Home","title":"TrypColonies.angle_between_vec","text":"angle_between_vec(v1::Vector{<:Real}, v2::Vector{<:Real}) -> Real\n\nCalculates the signed angle between two 2D vectors v1 and v2 using the arctangent of the 2D cross product and the dot product.\n\nArguments\n\nv1::Vector{Real}: The first 2D vector.\nv2::Vector{Real}: The second 2D vector.\n\nReturns\n\nReal: The angle between the two vectors in radians.\n\nExample\n\nv1 = [1.0, 0.0]\nv2 = [0.0, 1.0]\nangle = angle_between_vec(v1, v2)\n# angle is π/2 (1.5707963267948966 radians)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.angular_metric-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}","page":"Home","title":"TrypColonies.angular_metric","text":"angular_metric(agent_list::Vector{agent}, grid::AbstractArray, para::parameters; steps::Int = 360)\n\nCalculates the angular distribution of non-zero pixels in the grid relative to the center.\n\nArguments\n\nagent_list::Vector{agent}: A vector containing the agents.\ngrid::AbstractArray: The grid representing the simulation space.\npara::parameters: A struct containing various parameters, including the size of the grid.\nsteps::Int: The number of angular steps to divide the circle into (default is 360).\n\nDescription\n\nThis function calculates the angular distribution of non-zero pixels in the grid relative to the center.      It performs the following steps:\n\nInitializes a vector for the angular metric.\nCalculates the center of the grid.\nDetermines the size of each angular step in radians.\nIterates over each pixel in the grid and calculates the vector from the center to the pixel.\nCalculates the angle of the vector and determines the corresponding sector.\nIncrements the count for the sector.\nAdjusts the first and last sectors to account for discretization artifacts by taking their mean.\nReturns the angular metric.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.area_gain-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}","page":"Home","title":"TrypColonies.area_gain","text":"area_gain(agent_list::Vector{agent}, grids::Tuple{AbstractArray,AbstractArray}, para::parameters)\n\nCalculate the realtive gain in area walkable by agents in the grid.\n\nArguments\n\nagent_list::Vector{agent}: A list of agents.\ngrids::Tuple{AbstractArray, AbstractArray}: A tuple containing the grids.\npara::parameters: The parameters for the simulation.\n\nReturns\n\narea_gain::Float64: The ratio of the current area covered by agents to the original area.\n\nDescription\n\nThis function calculates the realtive gain in area covered by agents in the grid.      It compares the current area walkable by agents to the original area walkable by agents at the      start of the simulation. The original area is calculated using a newly created grid with the      same parameters, and the current area is calculated using the provided grid.\n\nExample\n\nagent_list = [...]  # List of agents\ngrids = (grid1, grid2)  # Tuple of grids\npara = parameters(...)  # Simulation parameters\ngain = area_gain(agent_list, grids, para)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.calc_path","page":"Home","title":"TrypColonies.calc_path","text":"Calculates reflection of agent on wall, calls itself up to 2 times recursivley if multiple reflections occur\n\n#(Image: reflection_calculus)\n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.calc_repulsion-Tuple{Any, Any, Any}","page":"Home","title":"TrypColonies.calc_repulsion","text":"calc_repulsion(all_list, index_rep, old_agent) -> Vector{Float64}\n\nCalculates the hard repulsion vector for an agent based on the positions of other agents in its vicinity.      The function normalizes the repulsion vectors and sums them to determine the overall direction of repulsion.\n\nArguments\n\nall_list: A list containing various attributes of all agents created by the function find_neighbour_agents.    The x and y positions of the agents are expected to be at indices 4 and 5, respectively.\nindex_rep: A list of indices representing the agents that are considered for repulsion.\nold_agent: An agent struct containing the current direction of the agent (dir_x and dir_y).\n\nReturns\n\nVector{Float64}: A normalized vector representing the direction of repulsion. If no repulsion is detected, it returns the normalized direction of the old_agent.\n\nExample Usage\n\nall_list = [...]  # Assume this is a list containing agent attributes\nindex_rep = [1, 2, 3]  # Indices of agents to consider for repulsion\nold_agent = Agent(1, 2, 0.5, 0.5)  # Assume this is an agent struct with direction fields\nrepulsion_vector = calc_repulsion(all_list, index_rep, old_agent)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.calculate_outgoing_vec-Tuple{TrypColonies.agent, Vector{Float64}}","page":"Home","title":"TrypColonies.calculate_outgoing_vec","text":"Calculates outgoing path of incoming particle, using raytracing formular and generic conventions:  #(Image: reflection_calculus)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.chemotactic_alignment-Tuple{Any, Any, Any, Any, Any, Any, Any, parameters}","page":"Home","title":"TrypColonies.chemotactic_alignment","text":"chemotactic_alignment(grad_x, grad_y, Y_pos, X_pos, X_dir, Y_dir, biggest_grad, para::parameters)\n\nAligns the direction of an agent based on the chemotactic gradient.\n\nArguments\n\ngrad_x: The gradient of the chemical concentration in the x direction.\ngrad_y: The gradient of the chemical concentration in the y direction.\nY_pos: The y position of the agent.\nX_pos: The x position of the agent.\nX_dir: The x component of the agent's direction.\nY_dir: The y component of the agent's direction.\nbiggest_grad: The largest gradient value for normalization.\npara::parameters: A struct containing various parameters, including the scale factor.\n\nDescription\n\nThis function aligns the direction of an agent based on the chemotactic gradient. It performs the following steps:\n\nScales the agent's position based on the scale factor.\nEnsures the scaled positions are not zero.\nCalculates the gradient direction at the agent's position.\nComputes the amplitude of the gradient and the angle between the agent's direction and the gradient direction.\nScales the angle by the amplitude of the gradient.\nConstructs a rotation matrix based on the scaled angle.\nRotates the agent's direction using the rotation matrix.\nReturns the new direction of the agent.\n\nExample\n\ngrad_x = rand(10, 10)\ngrad_y = rand(10, 10)\nY_pos = 5\nX_pos = 5\nX_dir = 1.0\nY_dir = 0.0\nbiggest_grad = 1.0\npara = parameters(pa_ph = pa_ph(scale_fac = 1.0))\n\nchemotactic_alignment(grad_x, grad_y, Y_pos, X_pos, X_dir, Y_dir, biggest_grad, para)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.chose_interaction_radius-Tuple{parameters}","page":"Home","title":"TrypColonies.chose_interaction_radius","text":"chose_interaction_radius(parameters::parameters) -> Float64\n\nDetermines the interaction radius to be used based on the given parameters. If the repulsion_flag is set,  it compares the repulsion_range with the interaction_radius and returns the larger of the two.   If the repulsion_flag is not set, it simply returns the interaction_radius.\n\nArguments\n\nparameters::parameters: A struct containing the simulation parameters, including:\nrepulsion_flag::Bool: A flag indicating whether repulsion is considered.\nrepulsion_range::Int: The range of repulsion.\ninteraction_radius::Int: The default interaction radius.\n\nReturns\n\nInt64: The chosen interaction radius based on the given parameters.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_buttons-Tuple{Makie.Figure, TrypColonies.Figure_observables, parameters, plot_parameters}","page":"Home","title":"TrypColonies.create_buttons","text":"create_buttons(f::Figure, fig_obs::Figure_observables, Parameters::parameters) -> (Button, Observable{parameters})\n\nCreates interactive UI elements, including a start/stop button and a grid of sliders, to control simulation parameters in a graphical figure.\n\nArguments\n\nf::Figure: The main figure where the UI elements will be added.\nfig_obs::Figure_observables: An observable object that includes the running state of the simulation.\nParameters::parameters: A struct containing the initial parameters for the simulation.\n\nReturns\n\n(Button, Observable{parameters}): A tuple containing the start/stop button and an observable parameter struct that updates based on the slider values.\n\nExample Usage\n\nf = Figure()\nfig_obs = Figure_observables(Isrunning = Observable(false))\nParameters = parameters(...)  # Assume this is the parameters struct with initial values\npause_button, para_obs = create_buttons(f, fig_obs, Parameters)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_data_path_vector-Tuple{Any}","page":"Home","title":"TrypColonies.create_data_path_vector","text":"create_data_path_vector(data_path) -> Vector{String}\n\nCreates a vector of full data paths by reading the contents of the specified directory or directories, excluding certain files.\n\nArguments\n\ndata_path: A string representing a single directory path or a vector of directory paths.\n\nReturns\n\nVector{String}: A vector of full paths to the data files in the specified directory or directories, excluding \"settings.csv\", \"settings.jls\", and \"analysis\".\n\nExample Usage\n\ndata_path = \"C:\\data\"\nfull_data_paths = create_data_path_vector(data_path)\n\ndata_paths = [\"C:\\data1\", \"C:\\data2\"]\nfull_data_paths = create_data_path_vector(data_paths)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_exp_scalar_grid-Tuple{parameters}","page":"Home","title":"TrypColonies.create_exp_scalar_grid","text":"create_exp_scalar_grid(para::parameters) -> Matrix{Float64}\n\nCreates a scalar grid based on a Gaussian distribution centered in the middle of the grid. The gradient values are calculated using the specified parameters.\n\nArguments\n\npara::parameters: A struct containing the parameters for the grid, including:\nsize::Tuple{Int, Int}: The dimensions of the grid.\n\nReturns\n\nMatrix{Float64}: A 2D array representing the gradient grid, with values following a Gaussian distribution.\n\nExample Usage\n\nparameters = parameters(size=(100, 100))\ngrad_grid = create_exp_scalar_grid(parameters)\n\nThis function is useful for creating a scalar field that can be used in simulations where agents respond to spatial gradients, such as chemotaxis or other gradient-based behaviors. \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_grids-Tuple{parameters}","page":"Home","title":"TrypColonies.create_grids","text":"create_grid(para::parameters) -> Matrix{Int64}\n\nCreate a grid based on the specified parameters. The function initializes a grid of zeros and modifies it according to  the geometry specified in Parameters. The grid can be shaped into a square, channel, circle, or a smaller circle, with negative values (defined by Parameters.grid_strength) in the entire grid except for the specified geometry shape.\n\nArguments\n\n- `para::parameters`: A struct containing the grid parameters. It must have the following fields:\n    - `size::Tuple{Int64, Int64}`: The dimensions of the grid.\n    - `geometry::String`: The shape of the grid, which can be \"square\", \"channel\", \"circle\", or \"circle_small\".\n    - `grid_strength::Int64`: The negative value to be applied to the grid's border or outside the specified shape.\n\nReturns\n\nMatrix{Int64}: The generated grid with the specified geometry and dimensions.\n\nExamples\n\nparams = parameters(size=(100, 100), geometry=\"square\", grid_strength=5)\ngrid = create_grid(params)\n\nThis function supports creating grids with different geometries to simulate various environments or constraints. \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_noise_dis-Tuple{parameters}","page":"Home","title":"TrypColonies.create_noise_dis","text":"`create_noise_dis(parameters::parameters)`\n\nCreate a noise distribution object based on the simulation parameters.\n\nArguments\n\nparameters::parameters: A struct containing the simulation parameters. This must include:\nnoise_dis: The type of distribution to use for noise. Expected to be either Uniform or Normal.\nnoise_strength: A parameter (η) that defines the strength of the noise. For a Uniform distribution, it defines the range [-η, η].      For a Normal distribution, it defines the standard deviation σ with a mean of 0.\n\nReturns\n\nA distribution object corresponding to the specified noise distribution and strength. If noise_strength is 0, \n\nit returns a Normal distribution with mean 0 and standard deviation 0.\n\nExample\n\nparameters = parameters(noise_dis=Uniform, noise_strength=0.5)\nnoise_distribution = create_noise_dis(parameters)\nThis will create a Uniform(-0.5, 0.5) distribution for noise.\n\nNotes\n\nThe function supports creating Uniform and Normal distributions based on the noise_dis parameter in parameters. If noise_strength (η) is set to 0, the function defaults to creating a Normal(0.0, 0.0) distribution,  effectively adding no noise.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_para_struct-Tuple{Dict}","page":"Home","title":"TrypColonies.create_para_struct","text":"create_para_struct(settings::Dict) -> parameters::parameters\n\nConstructs a parameters struct from a dictionary of settings, dynamically generating the struct fields      and their values based on the input dictionary. This function uses metaprogramming to parse and evaluate a       string representation of the struct initialization.\n\nArguments\n\nsettings::Dict: A dictionary where keys are the names of the parameters (as symbols or strings) and values are the\n\ncorresponding values for these parameters. The values can be of any type, including String.\n\nReturns\n\nA new instance of the parameters struct with fields and values corresponding to the entries in the settings dictionary.\n\nIf some keys are missing in the dictionary, the default values from the parameters struct definiton  will be used. \n\nExamples\n\nsettings = Dict(:radius_collision => 2, :size => (10,))\npara_struct = create_para_struct(settings)\n\nThis will create an instance of the parameters struct with radius_collision set to 2, size set to (10,10).\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_para_struct_vec-Tuple{Any}","page":"Home","title":"TrypColonies.create_para_struct_vec","text":"create_para_struct_vec(data_used) -> Vector{Vector{parameters}}\n\nCreates a vector of parameter structures from the given data. The function handles both 1-dimensional and 2-dimensional data inputs.\n\nArguments\n\ndata_used: The input data from which parameter structures are to be created. It can be a 1-dimensional or 2-dimensional array.\n\nReturns\n\nVector{Vector{parameters}}: A vector of vectors, where each inner vector contains parameter structures created from the input data.\n\nExample Usage\n\ndata_used = DataFrame(...)  # Assume this is a DataFrame with the necessary data\npara_vec = create_para_struct_vec(data_used)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_sweep_para_vec-Tuple{Any}","page":"Home","title":"TrypColonies.create_sweep_para_vec","text":"create_sweep_para_vec(data_used::DataFrame) -> Array{Array{Float64}}\n\nGenerates a vector of sweep parameter vectors based on the input data.\n\nArguments\n\ndata_used::DataFrame: An DataFrame where each row contains the sweep parameter information, including the sweep parameter name, start value, increment, and number of steps.\n\nReturns\n\nArray{Array{Float64}}: A vector of vectors, where each inner vector contains the sweep parameter values for a specific row in the input data.\n\nExample\n\ndata_used = Dataframe(\n    (sweep_parameter=\"param1\", param1=0.0, parameter_increment=0.1, parameter_steps=5,...),\n    (sweep_parameter=\"param2\", param2=1.0, parameter_increment=0.2, parameter_steps=3,...)\n)\nsweep_para_vec = create_sweep_para_vec(data_used)\n# sweep_para_vec is now [[0.0, 0.1, 0.2, 0.3, 0.4], [1.0, 1.2, 1.4]]\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.create_veloctiy_dis-Tuple{parameters}","page":"Home","title":"TrypColonies.create_veloctiy_dis","text":"create_velocity_dis(parameters::parameters) -> Distribution\n\nCreates a velocity distribution for agents based on the simulation parameters.\n\nArguments\n\nparameters::parameters: A struct containing the simulation parameters, which must include:\nvelocity_dis: The type of distribution to use (Uniform or Normal).\nvelocity_variance: The variance of the velocity distribution.\nvelocity: The mean velocity of the agents.\n\nReturns\n\nDistribution: A truncated distribution object representing the velocity distribution of agents.    The distribution is truncated at the lower bound of 0 to ensure that velocity values are non-negative.\n\nBehavior\n\nIf both velocity and velocity_variance are 0, a Normal distribution with mean 0 and variance 0 is returned.\nIf velocity_dis is Uniform, a truncated Uniform distribution ranging from (velocity - variance) to (velocity + variance) is created.\nIf velocity_dis is Normal, a truncated Normal distribution with the specified mean (velocity) and variance (velocity_variance) is created.\nThe truncation ensures that the resulting velocity values are always non-negative, as negative velocities are not physically meaningful in this context.\n\nExample\n\nparameters = parameters(velocity_dis=Normal, velocity_variance=1.0, velocity=5.0)\nvelocity_distribution = create_velocity_dis(parameters)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.cross_2d-Tuple{Vector{T} where T<:Real, Vector{T} where T<:Real}","page":"Home","title":"TrypColonies.cross_2d","text":"cross_2d(v1::Vector{<:Real}, v2::Vector{<:Real}) -> Real\n\nCalculates the 2D cross product (also known as the perp product) of two 2D vectors.\n\nArguments\n\nv1::Vector{Real}: The first 2D vector.\nv2::Vector{Real}: The second 2D vector.\n\nReturns\n\nReal: The scalar result of the 2D cross product.\n\nExample\n\nv1 = [1.0, 2.0]\nv2 = [3.0, 4.0]\nresult = cross_2d(v1, v2)\n# result is -2.0\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.find_data_path-Tuple{}","page":"Home","title":"TrypColonies.find_data_path","text":"find_data_path(data_paths; local=false) -> String\n\nFinds and returns the path to the data directory. If local is set to true, it checks for a directory named \"data\" in the current working directory and returns the path specified by data_paths[\"local_data\"] if found. If local is false or the local \"data\" directory is not found, it iterates through the data_paths dictionary and returns the first path that corresponds to an existing directory.\n\nArguments\n\ndata_paths::Dict{String,String}: A dictionary where keys are descriptive names of the paths and values are the actual paths to data directories.\nlocal::Bool=false (optional): A flag to indicate whether to look for a local \"data\" directory first.\n\nReturns\n\nString: The path to the data directory that was found.\n\nThrows\n\nArgumentError: If local is true but no local \"data\" directory is found.\n\nExamples\n\ndata_paths = Dict(\"local_data\" => \"./data\", \"remote_data\" => \"/mnt/data\")\npath = find_data_path(data_paths, local=true)\n\nThis function is useful for applications that need to flexibly switch between local and remote data sources.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.find_free_neighbour_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}","page":"Home","title":"TrypColonies.find_free_neighbour_points","text":"find_free_neighbour_points(grid::Matrix{Int64}, tryp::agent, Parameters::parameters) -> Tuple{Bool, Int64, Int64}\n\nFinds a free neighboring point around a given agent's position in a grid, considering specified boundary conditions.\n\nArguments\n\ngrid::Matrix{Int64}: A 2D grid representing the environment, where 0 indicates a free space and other values indicate occupied spaces.\ntryp::agent: An agent object with fields x_pos and y_pos indicating its current position in the grid.\nParameters::parameters: A parameters object containing simulation parameters, including boundary_conditions which can be \"periodic\" and size indicating the size of the grid.\n\nReturns\n\nsucess::Bool: A boolean indicating whether a free neighboring point was found.\nX_pos_new::Int64: The x-coordinate of the found free neighboring point. Returns the agent's original x-coordinate if no free point is found.\nY_pos_new::Int64: The y-coordinate of the found free neighboring point. Returns the agent's original y-coordinate if no free point is found.\n\nDescription\n\nThis function attempts to find a free (unoccupied) neighboring point around the agent's current position. It randomly shuffles the directions to check for free spaces to ensure unbiased movement direction. If the boundary_conditions are set to \"periodic\", it will apply periodic boundary corrections to wrap around the grid edges. The function returns whether a free space was found and the coordinates of that space.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.find_neighbour_agents-NTuple{4, Any}","page":"Home","title":"TrypColonies.find_neighbour_agents","text":"find_neighbour_agents(parameters, agent_list, i, interaction_radius, grid) -> Vector{Vector{Float64}}\n\nFinds the neighboring agents within a specified interaction radius for a given agent and returns their directional vectors, distances, and relative positions.\n\nArguments\n\nparameters: A struct containing the simulation parameters, including boundary conditions and grid size.\nagent_list: A list of agents, where each agent has attributes such as x_pos, y_pos, dir_x, and dir_y.\ni: The index of the agent for which neighbors are being found.\ninteraction_radius: The radius within which to search for neighboring agents.\ngrid: A 2D array representing the grid, where each cell contains the index of an agent or 0 if the cell is empty.\n\nReturns\n\nVector{Vector{Float64}}: A vector containing five vectors:\ndir_x_list: The x-components of the direction vectors of the neighboring agents.\ndir_y_list: The y-components of the direction vectors of the neighboring agents.\ndist_list: The distances from the given agent to each neighboring agent.\npos_x_list: The x-coordinates of the neighboring agents relative to the given agent.\npos_y_list: The y-coordinates of the neighboring agents relative to the given agent.\n\nExample Usage\n\nparameters = Parameters(boundary_conditions=\"periodic\", size=(100, 100))\nagent_list = [Agent(10, 10, 1.0, 0.0), Agent(12, 12, -1.0, 0.0)]  # Example agents\ngrid = zeros(Int64, 100, 100)\ngrid[10, 10] = 1\ngrid[12, 12] = 2\nneighbors = find_neighbour_agents(parameters, agent_list, 1, 5, grid)\n\nend\n\nThis function is useful for simulations where agents interact with their neighbors within a certain radius, such as in flocking or swarming behaviors.  It calculates the direction vectors, distances, and relative positions of neighboring agents,  which can be used to update the agent's direction based on the interactions.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.find_right_tangent_points-Tuple{Vector{Vector{Int64}}}","page":"Home","title":"TrypColonies.find_right_tangent_points","text":"Finds and returns the two most distant tangent points from a given array of tangent points.\n\nThis function is designed to process an array of tangent points, each represented as a Vector{Int64} containing two elements (coordinates). It calculates the pairwise distances between all points in the array using a helper function length_vec to determine the length of the vector formed by two points. The function then identifies and returns the pair of points that are the most distant from each other, which are considered the \"right\" tangent points for further processing.\n\nArguments\n\ntangent_points::Vector{Vector{Int64}}: An array of points, each point is a vector of two integers representing its coordinates.\n\nReturns\n\nVector{Vector{Int64}}: An array containing the two most distant tangent points from the input array.\n\nExample\n\ntangent_points = [[1, 2], [3, 4], [5, 6]]\nright_tangent_points = find_right_tangent_points(tangent_points)\n# right_tangent_points will contain the two points that are furthest apart\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.find_surounding_points-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}","page":"Home","title":"TrypColonies.find_surounding_points","text":"Returns all grid points surrounding the collision point in a radius of r  The discretization going from the continuous circle to the discrete points on the grid is done with the stepwidth:  steps \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.find_tangent_points-Tuple{Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"Home","title":"TrypColonies.find_tangent_points","text":"Reurn the gridpoints from the list of gridpoints in circle, which are the first ones of the boundary  by checking when there is a change in the value list of points from -1 to 0 or vice versa. The last gridpoint that has the  value -1 will be used as the probable point on the boundary between occupied and free space. \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.foldersize","page":"Home","title":"TrypColonies.foldersize","text":"foldersize\n\nCalculates the size of a directory in megabytes. If recursive is set to true, it computes the total size by recursively summing the sizes of all files within the directory and its subdirectories. If recursive is false, it returns the size of the directory itself, which may not be meaningful as directories typically have a small, fixed size.\n\nParameters:\n\ndirpath::String = pwd(): The path to the directory whose size is to be calculated.Defaults to the current working directory.\nrecursive::Bool = true: A flag indicating whether the size calculation should be recursive. Defaults to true.\n\nReturns:\n\nFloat64: The size of the directory in megabytes.\n\nExample Usage:\n\nsize = foldersize(\"/path/to/directory\", recursive=true)\n\nThis function is useful for monitoring disk usage by directories,      especially in applications where managing data storage is critical.\n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.get_reflected_vec-Tuple{Matrix{Int64}, TrypColonies.agent, parameters}","page":"Home","title":"TrypColonies.get_reflected_vec","text":"Return the normalized reflected vector from the tangent to the next boundary of a given grid point. Function includes a fallback  option, if no unambiguous tangent is defined by two points, the original orientation is just reversed.   \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.initialize_system-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}","page":"Home","title":"TrypColonies.initialize_system","text":"initialize_system!(grids::Tuple{Matrix{Int64}, Matrix{Float64}}, Parameters::parameters)\n\nInitializes the simulation system by setting up the initial configuration of agents and grid states.\n\nArguments\n\ngrids::Tuple{Matrix{Int64}, Matrix{Float64}}: A tuple containing two matrices. The first matrix represents the grid to be initialized.\nParameters::parameters: A struct containing various parameters, including the number of timesteps and other simulation parameters.\n\nDescription\n\nThis function initializes the system by setting up the initial configuration of agents and grid states. It performs the following steps:\n\nInitializes an empty list of agents.\nCreates a list to store the state of agents for each timestep.\nCalls random_start_config! to set up the initial configuration of the grid and agents.\nCopies the initial agent list to all timesteps.\nInitializes a sparse matrix vector to save grid changes.\nSaves the initial grid state to the sparse matrix vector.\n\nExample\n\ngrids = (Matrix{Int64}(undef, 10, 10), Matrix{Float64}(undef, 10, 10))\nParameters = parameters(pa_ph = pa_ph(time_steps_to_compute = 100), timesteps = 100)\n\ninitialize_system(grids, Parameters)\n\nReturns\n\ngrids: The initialized grids. agentlistfull: A list of agent states for each timestep. gridvecsparse: A vector of sparse matrices to save grid changes. \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.length_vec-Tuple{Vector{Int64}}","page":"Home","title":"TrypColonies.length_vec","text":"length_vec\n\nCalculates and returns the Euclidean length (magnitude) of a 2-dimensional vector represented by a Vector{Int64}.\n\nParameters:\n\nvec::Vector{Int64}: A vector with two elements where vec[1] is the x-component and vec[2] is the y-component of the vector.\n\nReturns:\n\nFloat64: The Euclidean length of the vector.\n\nExample Usage:\n\nvector = [3, 4]\nlength = length_vec(vector) # Returns 5.0\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.make_para_dict_list-Tuple{Any}","page":"Home","title":"TrypColonies.make_para_dict_list","text":"make_para_dict_list(sweep_dict_original::Dict)\n\nGenerate a list of parameter dictionaries for simulation runs based on the original sweep parameters dictionary.\n\nArguments\n\nsweep_dict_original::Dict: A dictionary containing the original sweep parameters. \n\nIt must include keys for sweep_parameter, parameter_steps,  iterations, and parameter_increment. The sweep_parameter key should match one of the keys in the dictionary   that will be varied across simulations.\n\nReturns\n\nArray{Dict}: An array of dictionaries, each representing a set of parameters for a single simulation run.\n\nThe specified sweep parameter is incremented across these dictionaries according to the parameter_steps   and parameter_increment specified in the original dictionary.\n\nThrows\n\nAn error if the sweep_parameter specified in sweep_dict_original does not exist in the dictionary keys.\n\nExample\n\nsweep_dict_original = Dict(\n    \"sweep_parameter\" => \"agent_number\",\n    \"parameter_steps\" => 5,\n    \"iterations\" => 10,\n    \"parameter_increment\" => 2,\n    \"other_param\" => 1\n)\npara_dict_list = make_para_dict_list(sweep_dict_original)\n\nThis function is useful for creating parameter sweeps for simulations,      where one wants to vary a single parameter across a range of values while keeping other parameters constant.  \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.make_sys_interactive!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, Any}","page":"Home","title":"TrypColonies.make_sys_interactive!","text":"make_sys_interactive!\n\nTransforms a grid system into an interactive one by initializing a circular buffer to store agent states, allowing for dynamic updates.\n\nParameters:\n\ngrids: The grids on which agents operate. This function does not modify the grid but returns it for consistency in the interface.\nagent_list_full: A list (vector) of agents. These agents are the initial state of the system.\nbuffer_length::Int=5 (optional): The length of the circular buffer. This determines how many past states of the agent list can be stored. Default is 5.\n\nReturns:\n\ngrids: The same grid passed as input, returned unchanged.\nagent_list_cicular: A circular buffer filled with deep copies of the first agent in agent_list_full.\n\nThis buffer allows for storing and accessing past states of the system.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.moving_avg","page":"Home","title":"TrypColonies.moving_avg","text":"moving_avg(X::Vector, numofele::Int=length(X)÷2)\n\nCalculates the moving average of a vector.\n\nArguments\n\nX::Vector: The input vector for which the moving average is to be calculated.\nnumofele::Int: The number of elements to consider for the moving average (default is half the length of X).\n\nDescription\n\nThis function calculates the moving average of the input vector X. It performs the following steps:\n\nDetermines the number of elements to look behind and ahead for the moving average.\nInitializes an output vector Y of the same length as X.\nIterates over each element in X and calculates the moving average for a range of elements around it.\nStores the calculated moving average in the output vector Y.\n\nExample\n\nX = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nnumofele = 3\n\nmoving_avg(X, numofele)\n\nReturns\n\nY::Vector: The vector containing the moving average values.\n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.nearby_neighbours-Tuple{Any, Any, Any}","page":"Home","title":"TrypColonies.nearby_neighbours","text":"nearby_neighbours(Agent_list::Vector{agent}, Grid::AbstractArray, Parameters::parameters)\n\nLegacy function to calculate the number of nearby neighbours for each agent within a      specified interaction range as an heatmap to then calculate the      average nearby topology of an agent.\n\nArguments\n\nAgent_list::Vector{agent}: A vector containing the agents.\nGrid::AbstractArray: The grid representing the simulation space.\nParameters::parameters: A struct containing various parameters, including the interaction radius.\n\nDescription\n\nThis function calculates the number of nearby neighbours for each agent within a specified interaction range. It performs the following steps:\n\nInitializes a sum grid to accumulate the number of neighbours.\nIterates over each agent and extracts a sub-grid around the agent's position within the interaction range.\nReplaces positive values in the sub-grid with 1 and negative values with 0.\nSets the agent's own position in the sub-grid to 0.\nAdds the sub-grid to the sum grid.\nReturns the rotated sum grid.\n\nExample\n\n```julia Agentlist = [agent(xpos=5, ypos=5), agent(xpos=10, ypos=10)] Grid = rand(-1:1, 20, 20) Parameters = parameters(interactionradius=2)\n\nnearbyneighbours(Agentlist, Grid, Parameters) Returns sum_grid: A grid representing the number of nearby neighbours for each agent. \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.path_tracing-Tuple{Matrix{Int64}, TrypColonies.agent, Any, parameters}","page":"Home","title":"TrypColonies.path_tracing","text":"Function Name: path_tracing\nDescription: This function simulates the movement of an agent (tryp) through a grid, step by step, to determine the point at which it first encounters a wall. It returns the X and Y positions on the grid where the first wall is encountered, along with the distance already walked.\nParameters:\ngrid::Matrix{Int64}: The grid through which the agent moves, represented as a matrix of integers.\ntryp::agent: The agent attempting to move through the grid. It contains properties like direction (dir_x, dir_y) and position (x_pos, y_pos).\nvelocity: The speed at which the agent attempts to move through the grid.\nparameters::parameters: Additional parameters affecting the simulation, such as boundary conditions.\nReturns: The function returns a tuple containing the X and Y indices of the first wall grid point encountered and the remaining distance the agent can walk.\nAlgorithm:\nInitialize the agent's direction and position.\nIterate through the steps based on the agent's velocity.\nUpdate the agent's position at each step, rounding to the nearest grid point.\nIf periodic boundary conditions are specified, adjust the position accordingly.\nCheck if the current grid point is a wall (grid[Y_step_i, X_step_i] < 0). If so, move the agent back to the previous position and adjust for periodic boundary conditions if necessary.\nReturn the final position and the distance walked before encountering the wall.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.periodic_boundary_correction-Tuple{Int64, Int64, Tuple{Int64, Int64}}","page":"Home","title":"TrypColonies.periodic_boundary_correction","text":"periodic_boundary_correction(x_pos::Int64, y_pos::Int64, size::Tuple{Int64,Int64}) -> Tuple{Int64, Int64}\n\nCorrects the positions (x_pos, y_pos) of an object within a 2D grid to ensure they fall within the grid's boundaries, assuming periodic boundary conditions. This means that if an object moves beyond one edge of the grid, it re-enters the grid from the opposite edge, similar to a toroidal (doughnut-shaped) space.\n\nArguments\n\nx_pos::Int64: The x-coordinate of the object's position.\ny_pos::Int64: The y-coordinate of the object's position.\nsize::Tuple{Int64,Int64}: A tuple representing the size of the grid, where the first element is the width (x dimension) and the second element is the height (y dimension).\n\nReturns\n\nTuple{Int64, Int64}: The corrected position of the object as a tuple of (x_pos, y_pos).\n\nExamples\n\n# Given a grid of size 10x10\ngrid_size = (10, 10)\n\n# An object at position (11, 5) would wrap around to (1, 5)\nperiodic_boundary_correction(11, 5, grid_size) # returns (1, 5)\n\n# An object at position (0, 10) would wrap around to (10, 10)\nperiodic_boundary_correction(0, 10, grid_size) # returns (10, 10)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.radial_density_c-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}","page":"Home","title":"TrypColonies.radial_density_c","text":"radial_density_c(agent_list::Vector{agent}, grids::Tuple{AbstractArray,AbstractArray}, para::parameters)\n\nCalculate the radial density of agents in a grid.\n\nArguments\n\nagent_list::Vector{agent}: A list of agents.\ngrids::Tuple{AbstractArray, AbstractArray}: A tuple containing the grids.\npara::parameters: The parameters for the simulation.\n\nReturns\n\ndist_vec_equal_oc::Vector{Float64}: A vector representing the normalized radial density of agents.\n\nDescription\n\nThis function calculates the radial density of agents in a grid by comparing all possible available      grid points where agents can be with the points where they actually are.       It sorts these points by their distance from the center of the grid and normalizes the        counts of these distances to provide a radial density distribution.\n\nExample\n\nagent_list = [...]  # List of agents\ngrids = (grid1, grid2)  # Tuple of grids\npara = parameters(...)  # Simulation parameters\ndensity = radial_density_c(agent_list, grids, para)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.radial_distribution-Tuple{Vector{TrypColonies.agent}, Tuple{AbstractArray, AbstractArray}, parameters}","page":"Home","title":"TrypColonies.radial_distribution","text":"radial_distribution(agent_list::Vector{agent}, size::Tuple{Int, Int})\n\nCalculates the radial distribution of agents from the center of the grid.\n\nArguments\n\nagent_list::Vector{agent} : A vector of agent objects.\nsize::Tuple{Int, Int}: A tuple containing the dimensions of the grid.\n\nDescription\n\nThis function calculates the radial distribution of agents from the center of the grid. It performs the following steps:\n\nCalculates the center of the grid.\nComputes the relative positions of the agents with respect to the center.\nCalculates the Euclidean distance of each agent from the center.\nBins the distances and normalizes by 1/(2r+1) to get the radial distribution.\n\nExample\n\nx_pos = [1, 3, 5, 7]\ny_pos = [2, 4, 6, 8]\nsize = (10, 10)\n\nradial_distribution(x_pos, y_pos, size)\n\nReturns\n\nVector{Int}: The radial distribution \nVector{Float}:   The distance vector, useable for histogram plotting    \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.reconstruct_grid!-Tuple{Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}, Int64, AbstractArray{Int64}}","page":"Home","title":"TrypColonies.reconstruct_grid!","text":"reconstruct_grid!(Grid_vec_sparse::Vector{SparseMatrixCSC{Int64, Int64}}, Timestep::Int, start_grid::AbstractArray{Int})\n\nUpdate start_grid in-place by adding the non-zero values from a specific timestep's sparse matrix in Grid_vec_sparse.\n\nArguments\n\nGrid_vec_sparse: A vector of sparse matrices (SparseMatrixCSC{Int64, Int64}), each representing the grid at a different timestep.\nTimestep: The specific timestep (index into Grid_vec_sparse) from which to take the non-zero values.\nstart_grid: An array to be updated in-place. It represents the grid before updating, and it will be modified to include the non-zero values from the specified timestep's sparse matrix.\n\nDescription\n\nThis function iterates over all non-zero elements of the sparse matrix at the specified Timestep in Grid_vec_sparse. For each non-zero element, it increments the corresponding element in start_grid by the value of the non-zero element. This operation modifies start_grid in-place, effectively reconstructing or updating the grid state by applying the changes from the specified timestep.\n\nExamples\n\n# Example usage\nGrid_vec_sparse = [sparse([1, 2], [1, 2], [1, 1]), sparse([1, 2], [1, 2], [2, 2])]\nTimestep = 2\nstart_grid = zeros(Int, 2, 2)\n\nreconstruct_grid!(Grid_vec_sparse, Timestep, start_grid)\n# start_grid is now [0 2; 0 2] (2x2 matrix of integers\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.reconstruct_grid_from_scratch","page":"Home","title":"TrypColonies.reconstruct_grid_from_scratch","text":"reconstruct_grid_from_scratch(Grid_vec_sparse::Vector{SparseMatrixCSC{Int64, Int64}}, Timestep::Int = length(Grid_vec_sparse)) -> Matrix{Int64}\n\nReconstructs the grid state from scratch up to a specified timestep using a sequence of sparse matrices.\n\nArguments\n\nGrid_vec_sparse: A vector of SparseMatrixCSC{Int64, Int64} objects, each representing the grid changes at a specific timestep.\nTimestep: (Optional) The timestep up to which the grid should be reconstructed. Defaults to the last available timestep in Grid_vec_sparse.\n\nReturns\n\nA Matrix{Int64} representing the reconstructed grid state up to the specified timestep.\n\nDescription\n\nThis function reconstructs the grid state by starting with the grid state at the first timestep      and then applying changes from each subsequent timestep up to the specified Timestep.       It uses the reconstruct_grid! function to apply changes in-place to the grid state.\n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.remove_fields_dict!-Tuple{Any}","page":"Home","title":"TrypColonies.remove_fields_dict!","text":"remove_fields_dict(dict::Dict{String, Any}) -> Dict{String, Any}\n\nRemoves keys from the given dictionary dict that are not present in the parameters structure.\n\nArguments\n\ndict::Dict{String, Any}: The dictionary from which keys will be removed.\n\nReturns\n\nDict{String, Any}: The modified dictionary with only the keys that are present in the parameters structure.\n\nExample\n\nparameters = (a=1, b=2)\ndict = Dict(\"a\" => 1, \"b\" => 2, \"c\" => 3)\nnew_dict = remove_fields_dict(dict)\n# new_dict is now Dict(\"a\" => 1, \"b\" => 2)\n\nThis function is useful for ensuring that a dictionary contains only valid keys before using it to set parameters in a simulation.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.res_scaling-Tuple{Any}","page":"Home","title":"TrypColonies.res_scaling","text":"res_scaling(image_number; factor::Real = 3.0, plots::Int = 1)\n\nCalculate the scaled width and height of an image based on the given factor and number of plots.\n\nArguments\n\nimage_number::Int: The number of the image to be scaled.\nfactor::Real: The scaling factor for the image dimensions. Default is 3.0.\nplots::Int: The number of plots to be considered in the width calculation. Default is 1.\n\nReturns\n\nwidth::Int: The scaled width of the image.\nheight::Int: The scaled height of the image.\n\nExample\n\nwidth, height = res_scaling(10, factor=2.5, plots=2)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.save_grid_changes!-Tuple{Matrix{Int64}, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}","page":"Home","title":"TrypColonies.save_grid_changes!","text":"save_grid_changes!(Grid_1::Union{Matrix{Int64}, Real}, Grid_2::Matrix{Int64}, Grid_vec::Vector{SparseMatrixCSC{Int64, Int64}})\n\nSubtracts Grid_1 from Grid_2 and appends the result to Grid_vec.\n\nArguments\n\nGrid_1: A matrix of integers or a real number. Represents the initial state of the grid.\nGrid_2: A matrix of integers. Represents the updated state of the grid.\nGrid_vec: A vector of sparse integer matrices. This vector is updated with the changes.\n\nNotes\n\nThis function modifies Grid_vec in place by appending the difference between Grid_2 and Grid_1.\nIf Grid_1 is a real number, it is subtracted from each element of Grid_2 before the result is appended to Grid_vec.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.scale_color_map-Tuple{Any, Any}","page":"Home","title":"TrypColonies.scale_color_map","text":"This function counteracts the dynamic scaling of colormaps in Makie if min and max values change over the course of an animation. It is given a Max value (min value = 0) and shrinks the colormap dynamically if the data does not reach the max value. \n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.scale_time_step-Tuple{Any, Any}","page":"Home","title":"TrypColonies.scale_time_step","text":"scale_time_step(dt_diff::Float64, dt_walker::Float64) -> Tuple{Float64, Float64}\n\nScales the time step dt_diff to be compatible with dt_walker.\n\nArguments\n\ndt_diff::Float64: The differential time step.\ndt_walker::Float64: The walker time step.\n\nReturns\n\nTuple{Float64, Float64}: A tuple containing the scaled dt_diff and the original dt_walker.\n\nDescription\n\nThis function adjusts the differential time step dt_diff to ensure it is compatible with the walker time step dt_walker. If dt_diff is greater than or equal to dt_walker, it is set to dt_walker. Otherwise, it is adjusted to be a divisor of dt_walker with a tolerance for floating-point precision.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.strenghten_boundary!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters}","page":"Home","title":"TrypColonies.strenghten_boundary!","text":"strenghten_boundary!(grids::Tuple{Matrix{Int64}, Matrix{Float64}}, Parameters::parameters)\n\nStrengthens the boundary of the grid by recovering the grid values based on a recovery rate.\n\nArguments\n\ngrids::Tuple{Matrix{Int64}, Matrix{Float64}}: A tuple containing two matrices. The first matrix represents the grid to be strengthened.\nParameters::parameters: A struct containing various parameters, including grid size, recovery rate, and grid strength.\n\nDescription\n\nThis function iterates over the grid and increases the grid values that are negative but greater than the negative grid strength.      The increase is determined by a Poisson distribution with a mean equal to the grid recovery rate.       If the updated grid value exceeds the negative grid strength, it is capped at the negative grid strength.\n\nExample\n\ngrids = (Matrix{Int64}(undef, 10, 10), Matrix{Float64}(undef, 10, 10))\nParameters = parameters(size = (10, 10), grid_recover_rate = 0.1, grid_strength = 5)\n\nstrenghten_boundary!(grids, Parameters)\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.sweep_and_save_parallel_t","page":"Home","title":"TrypColonies.sweep_and_save_parallel_t","text":"sweep_and_save_parallel_t(para_dict_list, full_data_path, offset=100000; threads=4)\n\nRun simulations in parallel and save the results.\n\nArguments\n\npara_dict_list::Vector{Dict}: A list of parameter dictionaries for each simulation.\nfull_data_path::String: The path where the simulation data will be saved.\noffset::Int: An offset for the file naming of the saved data. Default is 100000.\nthreads::Int: The number of threads to use for parallel execution. Default is 4.\n\nDescription\n\nThis function runs multiple simulations in parallel using the specified number of threads.      Each simulation is initialized with parameters from para_dict_list.      The simulation involves updating grids and agent lists over a series of time steps.      Data is sampled at specified intervals and stored in vectors.      After the simulation, the data is serialized and saved to full_data_path with filenames      based on the task index and offset.\n\nExample\n\npara_dict_list = [...]  # List of parameter dictionaries\nfull_data_path = \"path/to/save/data\"\nsweep_and_save_parallel_t(para_dict_list, full_data_path, offset=100000, threads=4) \n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.update_grid!-Tuple{Tuple{Matrix{Int64}, Matrix{Float64}}, parameters, Matrix{Int64}, Vector{SparseArrays.SparseMatrixCSC{Int64, Int64}}}","page":"Home","title":"TrypColonies.update_grid!","text":"update_grid!(grid::Matrix{Int}, Parameters::parameters, grid_t::Matrix{Int}, grid_vec_sparse::Vector{SparseMatrixCSC{Int64, Int64}})\n\nUpdates the simulation grid by strengthening boundaries and saving grid changes.\n\nArguments\n\ngrid: The current state of the simulation grid as a matrix of integers.\nParameters: A struct containing simulation parameters, such as grid size and boundary strength.\ngrid_t: A reference grid state used for comparison when saving changes.\ngrid_vec_sparse: A vector of sparse matrices where changes to the grid are stored.\n\nDescription\n\nThis function performs two main operations on the simulation grid:\n\nIt calls strengthen_boundary! to modify the grid's boundaries based on the Parameters. This typically involves making the boundaries more negative (stronger) according to a predefined strength parameter.\nIt calls save_grid_changes! to compare the current grid state (grid) with a reference state (grid_t) and records the differences in grid_vec_sparse. This step is crucial for tracking the evolution of the grid over time in an efficient manner.\n\n\n\n\n\n","category":"method"},{"location":"#TrypColonies.update_position!","page":"Home","title":"TrypColonies.update_position!","text":"update_position!(grid::Matrix{Int64}, full_agent_list, Parameters::parameters, timestep=1)\n\nUpdates the positions of agents on a grid based on their velocities and directions.\n\nArguments\n\ngrid::Matrix{Int64}: A 2D grid representing the environment where each cell can be empty (0), occupied by an agent (positive non-zero) or part of unmoveable space (negative non-zero).\nfull_agent_list: A collection of agents. Can be a CircularBuffer{Vector{agent}} for interactive/infinite simulations or a simple Vector{agent} for static/finite simulations.\nParameters::parameters: A struct containing simulation parameters, including velocity distribution, boundary conditions, and whether path tracing is enabled.\ntimestep=1: The current timestep of the simulation. Defaults to 1.\n\nBehavior\n\nDetermines the velocity distribution for agents based on the provided parameters.\nDraws a random velocity for each agent from the distribution. \nDecides on the agent list to use based on the type of simulation (interactive/infinite vs. static/finite).\nIterates through each agent, calculating their new position based on their velocity and direction.\nIf path_tracing is disabled, agents move directly to their new position if it's empty, respecting boundary conditions.\nIf path_tracing is enabled, calculates a path for the agent and moves them along this path and interacts with the non movable space,    also respecting boundary conditions and handling sliding boundary conditions if enabled.\nUpdates the grid to reflect the new positions of the agents.\nUpdates the non movable space if the boundary is moveable.\n\nNote\n\nThis function modifies the grid and full_agent_list in place.\nAgents are assumed to be immutable; thus, to update an agent's position, a new agent with the updated position is created and replaced in the list.\n\n\n\n\n\n","category":"function"},{"location":"#TrypColonies.@h-Tuple{Any}","page":"Home","title":"TrypColonies.@h","text":"@h methodname\n\nOutputs documentations in jupyternotenbooks in VScode as markdown without bugs.\n\nExample of how to use the @h macro:\n\n@h res_scaling\n\nOutputs documentations in jupyternotenbooks in VScode as markdown without bugs.\n\n\n\n\n\n","category":"macro"}]
}
